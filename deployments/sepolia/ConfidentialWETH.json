{
  "address": "0xc5a75d90a561Da40a91657b60705C1fd984Ef76a",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "name": "ConfidentialFungibleTokenInvalidGatewayRequest",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "ConfidentialFungibleTokenInvalidReceiver",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ConfidentialFungibleTokenInvalidSender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "ConfidentialFungibleTokenUnauthorizedCaller",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "holder",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "ConfidentialFungibleTokenUnauthorizedSpender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "euint64",
          "name": "amount",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "holder",
          "type": "address"
        }
      ],
      "name": "ConfidentialFungibleTokenZeroBalance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "HandlesAlreadySavedForRequestID",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidKMSSignatures",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoHandleFoundForRequestID",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnsupportedHandleType",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "euint64",
          "name": "encryptedAmount",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "amount",
          "type": "uint64"
        }
      ],
      "name": "AmountDisclosed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "ConfidentialDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "euint64",
          "name": "amount",
          "type": "bytes32"
        }
      ],
      "name": "ConfidentialTransfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "ConfidentialUnwrap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "ConfidentialWithdrawal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "ConfidentialWrap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "requestID",
          "type": "uint256"
        }
      ],
      "name": "DecryptionFulfilled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "holder",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "until",
          "type": "uint48"
        }
      ],
      "name": "OperatorSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "confidentialBalanceOf",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "confidentialTotalSupply",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "externalEuint64",
          "name": "encryptedAmount",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        }
      ],
      "name": "confidentialTransfer",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "euint64",
          "name": "amount",
          "type": "bytes32"
        }
      ],
      "name": "confidentialTransfer",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "euint64",
          "name": "amount",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "confidentialTransferAndCall",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "transferred",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "externalEuint64",
          "name": "encryptedAmount",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "confidentialTransferAndCall",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "transferred",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "externalEuint64",
          "name": "encryptedAmount",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        }
      ],
      "name": "confidentialTransferFrom",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "transferred",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "euint64",
          "name": "amount",
          "type": "bytes32"
        }
      ],
      "name": "confidentialTransferFrom",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "transferred",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "externalEuint64",
          "name": "encryptedAmount",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "confidentialTransferFromAndCall",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "transferred",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "euint64",
          "name": "amount",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "confidentialTransferFromAndCall",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "transferred",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "euint64",
          "name": "encryptedAmount",
          "type": "bytes32"
        }
      ],
      "name": "discloseEncryptedAmount",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "emergencyWithdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "amount",
          "type": "uint64"
        },
        {
          "internalType": "bytes[]",
          "name": "signatures",
          "type": "bytes[]"
        }
      ],
      "name": "finalizeDiscloseEncryptedAmount",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getEncryptedBalance",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getEncryptedTotalSupply",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "holder",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "isOperator",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "uint48",
          "name": "until",
          "type": "uint48"
        }
      ],
      "name": "setOperator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wrap",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0xce6be026d42d008a57f946da6d5fbf3e88f84a355936e5f50feaaca74fb10641",
  "receipt": {
    "to": null,
    "from": "0x8CE3b7f1C817Ca39123A419467365915567B1B75",
    "contractAddress": "0xc5a75d90a561Da40a91657b60705C1fd984Ef76a",
    "transactionIndex": 54,
    "gasUsed": "2274768",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000100000000000000000000000020200000000000010000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc95821d1b9f92e066c10c3d380de73320a46ddf6f28ee541e43f43446de7005a",
    "transactionHash": "0xce6be026d42d008a57f946da6d5fbf3e88f84a355936e5f50feaaca74fb10641",
    "logs": [
      {
        "transactionIndex": 54,
        "blockNumber": 9292784,
        "transactionHash": "0xce6be026d42d008a57f946da6d5fbf3e88f84a355936e5f50feaaca74fb10641",
        "address": "0xc5a75d90a561Da40a91657b60705C1fd984Ef76a",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000008ce3b7f1c817ca39123a419467365915567b1b75"
        ],
        "data": "0x",
        "logIndex": 45,
        "blockHash": "0xc95821d1b9f92e066c10c3d380de73320a46ddf6f28ee541e43f43446de7005a"
      }
    ],
    "blockNumber": 9292784,
    "cumulativeGasUsed": "10324250",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "03064d48f085e9c954f548034a96cc8f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"ConfidentialFungibleTokenInvalidGatewayRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ConfidentialFungibleTokenInvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ConfidentialFungibleTokenInvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ConfidentialFungibleTokenUnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ConfidentialFungibleTokenUnauthorizedSpender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"euint64\",\"name\":\"amount\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"ConfidentialFungibleTokenZeroBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HandlesAlreadySavedForRequestID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidKMSSignatures\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandleFoundForRequestID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedHandleType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"euint64\",\"name\":\"encryptedAmount\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"}],\"name\":\"AmountDisclosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ConfidentialDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"euint64\",\"name\":\"amount\",\"type\":\"bytes32\"}],\"name\":\"ConfidentialTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ConfidentialUnwrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ConfidentialWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ConfidentialWrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestID\",\"type\":\"uint256\"}],\"name\":\"DecryptionFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"until\",\"type\":\"uint48\"}],\"name\":\"OperatorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"confidentialBalanceOf\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confidentialTotalSupply\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"externalEuint64\",\"name\":\"encryptedAmount\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"}],\"name\":\"confidentialTransfer\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"euint64\",\"name\":\"amount\",\"type\":\"bytes32\"}],\"name\":\"confidentialTransfer\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"euint64\",\"name\":\"amount\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"confidentialTransferAndCall\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"transferred\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"externalEuint64\",\"name\":\"encryptedAmount\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"confidentialTransferAndCall\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"transferred\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"externalEuint64\",\"name\":\"encryptedAmount\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"}],\"name\":\"confidentialTransferFrom\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"transferred\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"euint64\",\"name\":\"amount\",\"type\":\"bytes32\"}],\"name\":\"confidentialTransferFrom\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"transferred\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"externalEuint64\",\"name\":\"encryptedAmount\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"confidentialTransferFromAndCall\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"transferred\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"euint64\",\"name\":\"amount\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"confidentialTransferFromAndCall\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"transferred\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"euint64\",\"name\":\"encryptedAmount\",\"type\":\"bytes32\"}],\"name\":\"discloseEncryptedAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"finalizeDiscloseEncryptedAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getEncryptedBalance\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEncryptedTotalSupply\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"until\",\"type\":\"uint48\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"details\":\"This contract allows users to wrap ETH into confidential WETH tokens\",\"errors\":{\"ConfidentialFungibleTokenInvalidGatewayRequest(uint256)\":[{\"details\":\"The given gateway request ID `requestId` is invalid.\"}],\"ConfidentialFungibleTokenInvalidReceiver(address)\":[{\"details\":\"The given receiver `receiver` is invalid for transfers.\"}],\"ConfidentialFungibleTokenInvalidSender(address)\":[{\"details\":\"The given sender `sender` is invalid for transfers.\"}],\"ConfidentialFungibleTokenUnauthorizedCaller(address)\":[{\"details\":\"The given caller `caller` is not authorized for the current operation.\"}],\"ConfidentialFungibleTokenUnauthorizedSpender(address,address)\":[{\"details\":\"The given holder `holder` is not authorized to spend on behalf of `spender`.\"}],\"ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(bytes32,address)\":[{\"details\":\"The caller `user` does not have access to the encrypted amount `amount`. NOTE: Try using the equivalent transfer function with an input proof.\"}],\"ConfidentialFungibleTokenZeroBalance(address)\":[{\"details\":\"The holder `holder` is trying to send tokens but has a balance of 0.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"events\":{\"AmountDisclosed(bytes32,uint64)\":{\"details\":\"Emitted when an encrypted amount is disclosed. Accounts with access to the encrypted amount `encryptedAmount` that is also accessible to this contract should be able to disclose the amount. This functionality is implementation specific.\"},\"ConfidentialTransfer(address,address,bytes32)\":{\"details\":\"Emitted when a confidential transfer is made from `from` to `to` of encrypted amount `amount`.\"},\"OperatorSet(address,address,uint48)\":{\"details\":\"Emitted when the expiration timestamp for an operator `operator` is updated for a given `holder`. The operator may move any amount of tokens on behalf of the holder until the timestamp `until`.\"}},\"kind\":\"dev\",\"methods\":{\"confidentialBalanceOf(address)\":{\"details\":\"Returns the confidential balance of the account `account`.\"},\"confidentialTotalSupply()\":{\"details\":\"Returns the confidential total supply of the token.\"},\"confidentialTransfer(address,bytes32)\":{\"details\":\"Similar to {confidentialTransfer-address-externalEuint64-bytes} but without an input proof. The caller *must* already be allowed by ACL for the given `amount`.\"},\"confidentialTransfer(address,bytes32,bytes)\":{\"details\":\"Transfers the encrypted amount `encryptedAmount` to `to` with the given input proof `inputProof`. Returns the encrypted amount that was actually transferred.\"},\"confidentialTransferAndCall(address,bytes32,bytes)\":{\"details\":\"Similar to {confidentialTransfer-address-euint64} but with a callback to `to` after the transfer.\"},\"confidentialTransferAndCall(address,bytes32,bytes,bytes)\":{\"details\":\"Similar to {confidentialTransfer-address-externalEuint64-bytes} but with a callback to `to` after the transfer. The callback is made to the {IConfidentialFungibleTokenReceiver-onConfidentialTransferReceived} function on the to address with the actual transferred amount (may differ from the given `encryptedAmount`) and the given data `data`.\"},\"confidentialTransferFrom(address,address,bytes32)\":{\"details\":\"Similar to {confidentialTransferFrom-address-address-externalEuint64-bytes} but without an input proof. The caller *must* be already allowed by ACL for the given `amount`.\"},\"confidentialTransferFrom(address,address,bytes32,bytes)\":{\"details\":\"Transfers the encrypted amount `encryptedAmount` from `from` to `to` with the given input proof `inputProof`. `msg.sender` must be either `from` or an operator for `from`. Returns the encrypted amount that was actually transferred.\"},\"confidentialTransferFromAndCall(address,address,bytes32,bytes)\":{\"details\":\"Similar to {confidentialTransferFrom-address-address-euint64} but with a callback to `to` after the transfer.\"},\"confidentialTransferFromAndCall(address,address,bytes32,bytes,bytes)\":{\"details\":\"Similar to {confidentialTransferFrom-address-address-externalEuint64-bytes} but with a callback to `to` after the transfer.\"},\"decimals()\":{\"details\":\"Returns the number of decimals of the token. Recommended to be 6.\"},\"discloseEncryptedAmount(bytes32)\":{\"details\":\"Discloses an encrypted amount `encryptedAmount` publicly via an {IConfidentialFungibleToken-AmountDisclosed} event. The caller and this contract must be authorized to use the encrypted amount on the ACL. NOTE: This is an asynchronous operation where the actual decryption happens off-chain and {finalizeDiscloseEncryptedAmount} is called with the result.\"},\"emergencyWithdraw()\":{\"details\":\"This function should only be used in emergency situations\"},\"finalizeDiscloseEncryptedAmount(uint256,uint64,bytes[])\":{\"details\":\"Finalizes a disclose encrypted amount request.\"},\"getEncryptedBalance(address)\":{\"params\":{\"user\":\"The user address\"},\"returns\":{\"_0\":\"The encrypted balance\"}},\"getEncryptedTotalSupply()\":{\"returns\":{\"_0\":\"The encrypted total supply\"}},\"isOperator(address,address)\":{\"details\":\"Returns true if `spender` is currently an operator for `holder`.\"},\"name()\":{\"details\":\"Returns the name of the token.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setOperator(address,uint48)\":{\"details\":\"Sets `operator` as an operator for `holder` until the timestamp `until`. NOTE: An operator may transfer any amount of tokens on behalf of a holder while approved.\"},\"symbol()\":{\"details\":\"Returns the symbol of the token.\"},\"tokenURI()\":{\"details\":\"Returns the token URI.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"wrap()\":{\"details\":\"Users send ETH and receive encrypted cWETH tokensCONFIDENTIAL: No plaintext amounts are exposed\"}},\"title\":\"Confidential WETH (cWETH)\",\"version\":1},\"userdoc\":{\"errors\":{\"HandlesAlreadySavedForRequestID()\":[{\"notice\":\"Returned if some handles were already saved for corresponding ID.\"}],\"InvalidKMSSignatures()\":[{\"notice\":\"Returned if the returned KMS signatures are not valid.\"}],\"NoHandleFoundForRequestID()\":[{\"notice\":\"Returned if there was not handle found for the requested ID.\"}],\"UnsupportedHandleType()\":[{\"notice\":\"Returned if the requested handle to be decrypted is not of a supported type.\"}]},\"events\":{\"DecryptionFulfilled(uint256)\":{\"notice\":\"This event is emitted when requested decryption has been fulfilled.\"}},\"kind\":\"user\",\"methods\":{\"emergencyWithdraw()\":{\"notice\":\"Emergency function to withdraw ETH (only owner)\"},\"getEncryptedBalance(address)\":{\"notice\":\"Get encrypted balance of a user\"},\"getEncryptedTotalSupply()\":{\"notice\":\"Get encrypted total supply\"},\"wrap()\":{\"notice\":\"Wrap ETH into confidential WETH\"}},\"notice\":\"ERC7984 implementation for confidential WETH with wrap/unwrap functionality\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ConfidentialWETH.sol\":\"ConfidentialWETH\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@fhevm/solidity/lib/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\nimport {FheType} from \\\"./FheType.sol\\\";\\n\\nimport \\\"encrypted-types/EncryptedTypes.sol\\\";\\n\\n/**\\n * @title IKMSVerifier\\n * @notice This interface contains the only function required from KMSVerifier.\\n */\\ninterface IKMSVerifier {\\n    function verifyDecryptionEIP712KMSSignatures(\\n        bytes32[] memory handlesList,\\n        bytes memory decryptedResult,\\n        bytes[] memory signatures\\n    ) external returns (bool);\\n}\\n\\n/**\\n * @title IDecryptionOracle\\n * @notice This interface contains the only function required from DecryptionOracle.\\n */\\ninterface IDecryptionOracle {\\n    function requestDecryption(\\n        uint256 requestID,\\n        bytes32[] calldata ctsHandles,\\n        bytes4 callbackSelector\\n    ) external payable;\\n}\\n\\n/**\\n * @title   FHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with the FHEVM protocol.\\n */\\nlibrary FHE {\\n    /// @notice Returned if some handles were already saved for corresponding ID.\\n    error HandlesAlreadySavedForRequestID();\\n\\n    /// @notice Returned if there was not handle found for the requested ID.\\n    error NoHandleFoundForRequestID();\\n\\n    /// @notice Returned if the returned KMS signatures are not valid.\\n    error InvalidKMSSignatures();\\n\\n    /// @notice Returned if the requested handle to be decrypted is not of a supported type.\\n    error UnsupportedHandleType();\\n\\n    /// @notice This event is emitted when requested decryption has been fulfilled.\\n    event DecryptionFulfilled(uint256 indexed requestID);\\n\\n    /**\\n     * @notice            Sets the coprocessor addresses.\\n     * @param fhevmConfig FHEVM config struct that contains contract addresses.\\n     */\\n    function setCoprocessor(FHEVMConfigStruct memory fhevmConfig) internal {\\n        Impl.setCoprocessor(fhevmConfig);\\n    }\\n\\n    /**\\n     * @notice                  Sets the decryption oracle address.\\n     * @param decryptionOracle  The decryption oracle address.\\n     */\\n    function setDecryptionOracle(address decryptionOracle) internal {\\n        Impl.setDecryptionOracle(decryptionOracle);\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Evaluates and(ebool a, ebool b) and returns the result.\\n     */\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(ebool a, ebool b) and returns the result.\\n     */\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(ebool a, ebool b) and returns the result.\\n     */\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(ebool a, ebool b) and returns the result.\\n     */\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(ebool a, ebool b) and returns the result.\\n     */\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(eaddress a, eaddress b) and returns the result.\\n     */\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(eaddress a, eaddress b) and returns the result.\\n     */\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(ebool a, bool b) and returns the result.\\n     */\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(bool a, ebool b) and returns the result.\\n     */\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(ebool a, bool b) and returns the result.\\n     */\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(bool a, ebool b) and returns the result.\\n     */\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(ebool a, bool b) and returns the result.\\n     */\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(bool a, ebool b) and returns the result.\\n     */\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(ebool a, bool b) and returns the result.\\n     */\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(bool a, ebool b) and returns the result.\\n     */\\n    function eq(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(ebool a, bool b) and returns the result.\\n     */\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(bool a, ebool b) and returns the result.\\n     */\\n    function ne(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, uint8 b) and returns the result.\\n     */\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint8 a, euint8 b) and returns the result.\\n     */\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, uint8 b) and returns the result.\\n     */\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint8 a, euint8 b) and returns the result.\\n     */\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, uint8 b) and returns the result.\\n     */\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint8 a, euint8 b) and returns the result.\\n     */\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint8 a, uint8 b) and returns the result.\\n     */\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint8 a, uint8 b) and returns the result.\\n     */\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, uint8 b) and returns the result.\\n     */\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint8 a, euint8 b) and returns the result.\\n     */\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, uint8 b) and returns the result.\\n     */\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint8 a, euint8 b) and returns the result.\\n     */\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, uint8 b) and returns the result.\\n     */\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint8 a, euint8 b) and returns the result.\\n     */\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, uint8 b) and returns the result.\\n     */\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint8 a, euint8 b) and returns the result.\\n     */\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, uint8 b) and returns the result.\\n     */\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint8 a, euint8 b) and returns the result.\\n     */\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, uint8 b) and returns the result.\\n     */\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint8 a, euint8 b) and returns the result.\\n     */\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, uint8 b) and returns the result.\\n     */\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint8 a, euint8 b) and returns the result.\\n     */\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, uint8 b) and returns the result.\\n     */\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint8 a, euint8 b) and returns the result.\\n     */\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, uint8 b) and returns the result.\\n     */\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint8 a, euint8 b) and returns the result.\\n     */\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, uint8 b) and returns the result.\\n     */\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint8 a, euint8 b) and returns the result.\\n     */\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, uint8 b) and returns the result.\\n     */\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint8 a, euint8 b) and returns the result.\\n     */\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, uint16 b) and returns the result.\\n     */\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint16 a, euint16 b) and returns the result.\\n     */\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, uint16 b) and returns the result.\\n     */\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint16 a, euint16 b) and returns the result.\\n     */\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, uint16 b) and returns the result.\\n     */\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint16 a, euint16 b) and returns the result.\\n     */\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint16 a, uint16 b) and returns the result.\\n     */\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint16 a, uint16 b) and returns the result.\\n     */\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, uint16 b) and returns the result.\\n     */\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint16 a, euint16 b) and returns the result.\\n     */\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, uint16 b) and returns the result.\\n     */\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint16 a, euint16 b) and returns the result.\\n     */\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, uint16 b) and returns the result.\\n     */\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint16 a, euint16 b) and returns the result.\\n     */\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, uint16 b) and returns the result.\\n     */\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint16 a, euint16 b) and returns the result.\\n     */\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, uint16 b) and returns the result.\\n     */\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint16 a, euint16 b) and returns the result.\\n     */\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, uint16 b) and returns the result.\\n     */\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint16 a, euint16 b) and returns the result.\\n     */\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, uint16 b) and returns the result.\\n     */\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint16 a, euint16 b) and returns the result.\\n     */\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, uint16 b) and returns the result.\\n     */\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint16 a, euint16 b) and returns the result.\\n     */\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, uint16 b) and returns the result.\\n     */\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint16 a, euint16 b) and returns the result.\\n     */\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, uint16 b) and returns the result.\\n     */\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint16 a, euint16 b) and returns the result.\\n     */\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, uint16 b) and returns the result.\\n     */\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint16 a, euint16 b) and returns the result.\\n     */\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, uint32 b) and returns the result.\\n     */\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint32 a, euint32 b) and returns the result.\\n     */\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, uint32 b) and returns the result.\\n     */\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint32 a, euint32 b) and returns the result.\\n     */\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, uint32 b) and returns the result.\\n     */\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint32 a, euint32 b) and returns the result.\\n     */\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint32 a, uint32 b) and returns the result.\\n     */\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint32 a, uint32 b) and returns the result.\\n     */\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, uint32 b) and returns the result.\\n     */\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint32 a, euint32 b) and returns the result.\\n     */\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, uint32 b) and returns the result.\\n     */\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint32 a, euint32 b) and returns the result.\\n     */\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, uint32 b) and returns the result.\\n     */\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint32 a, euint32 b) and returns the result.\\n     */\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, uint32 b) and returns the result.\\n     */\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint32 a, euint32 b) and returns the result.\\n     */\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, uint32 b) and returns the result.\\n     */\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint32 a, euint32 b) and returns the result.\\n     */\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, uint32 b) and returns the result.\\n     */\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint32 a, euint32 b) and returns the result.\\n     */\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, uint32 b) and returns the result.\\n     */\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint32 a, euint32 b) and returns the result.\\n     */\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, uint32 b) and returns the result.\\n     */\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint32 a, euint32 b) and returns the result.\\n     */\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, uint32 b) and returns the result.\\n     */\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint32 a, euint32 b) and returns the result.\\n     */\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, uint32 b) and returns the result.\\n     */\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint32 a, euint32 b) and returns the result.\\n     */\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, uint32 b) and returns the result.\\n     */\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint32 a, euint32 b) and returns the result.\\n     */\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, uint64 b) and returns the result.\\n     */\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint64 a, euint64 b) and returns the result.\\n     */\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, uint64 b) and returns the result.\\n     */\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint64 a, euint64 b) and returns the result.\\n     */\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, uint64 b) and returns the result.\\n     */\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint64 a, euint64 b) and returns the result.\\n     */\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint64 a, uint64 b) and returns the result.\\n     */\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint64 a, uint64 b) and returns the result.\\n     */\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, uint64 b) and returns the result.\\n     */\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint64 a, euint64 b) and returns the result.\\n     */\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, uint64 b) and returns the result.\\n     */\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint64 a, euint64 b) and returns the result.\\n     */\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, uint64 b) and returns the result.\\n     */\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint64 a, euint64 b) and returns the result.\\n     */\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, uint64 b) and returns the result.\\n     */\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint64 a, euint64 b) and returns the result.\\n     */\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, uint64 b) and returns the result.\\n     */\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint64 a, euint64 b) and returns the result.\\n     */\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, uint64 b) and returns the result.\\n     */\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint64 a, euint64 b) and returns the result.\\n     */\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, uint64 b) and returns the result.\\n     */\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint64 a, euint64 b) and returns the result.\\n     */\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, uint64 b) and returns the result.\\n     */\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint64 a, euint64 b) and returns the result.\\n     */\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, uint64 b) and returns the result.\\n     */\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint64 a, euint64 b) and returns the result.\\n     */\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, uint64 b) and returns the result.\\n     */\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint64 a, euint64 b) and returns the result.\\n     */\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, uint64 b) and returns the result.\\n     */\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint64 a, euint64 b) and returns the result.\\n     */\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, uint128 b) and returns the result.\\n     */\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint128 a, euint128 b) and returns the result.\\n     */\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, uint128 b) and returns the result.\\n     */\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint128 a, euint128 b) and returns the result.\\n     */\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, uint128 b) and returns the result.\\n     */\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint128 a, euint128 b) and returns the result.\\n     */\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint128 a, uint128 b) and returns the result.\\n     */\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint128 a, uint128 b) and returns the result.\\n     */\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, uint128 b) and returns the result.\\n     */\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint128 a, euint128 b) and returns the result.\\n     */\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, uint128 b) and returns the result.\\n     */\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint128 a, euint128 b) and returns the result.\\n     */\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, uint128 b) and returns the result.\\n     */\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint128 a, euint128 b) and returns the result.\\n     */\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, uint128 b) and returns the result.\\n     */\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint128 a, euint128 b) and returns the result.\\n     */\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, uint128 b) and returns the result.\\n     */\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint128 a, euint128 b) and returns the result.\\n     */\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, uint128 b) and returns the result.\\n     */\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint128 a, euint128 b) and returns the result.\\n     */\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, uint128 b) and returns the result.\\n     */\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint128 a, euint128 b) and returns the result.\\n     */\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, uint128 b) and returns the result.\\n     */\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint128 a, euint128 b) and returns the result.\\n     */\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, uint128 b) and returns the result.\\n     */\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint128 a, euint128 b) and returns the result.\\n     */\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, uint128 b) and returns the result.\\n     */\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint128 a, euint128 b) and returns the result.\\n     */\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, uint128 b) and returns the result.\\n     */\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint128 a, euint128 b) and returns the result.\\n     */\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(eaddress a, address b) and returns the result.\\n     */\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(address a, eaddress b) and returns the result.\\n     */\\n    function eq(address a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(eaddress a, address b) and returns the result.\\n     */\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(address a, eaddress b) and returns the result.\\n     */\\n    function ne(address a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, uint256 b) and returns the result.\\n     */\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint256 a, euint256 b) and returns the result.\\n     */\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, uint256 b) and returns the result.\\n     */\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint256 a, euint256 b) and returns the result.\\n     */\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, uint256 b) and returns the result.\\n     */\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint256 a, euint256 b) and returns the result.\\n     */\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, uint256 b) and returns the result.\\n     */\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint256 a, euint256 b) and returns the result.\\n     */\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, uint256 b) and returns the result.\\n     */\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint256 a, euint256 b) and returns the result.\\n     */\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint8 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint8 a, uint8) and returns the result.\\n     */\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint8 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint8 a, uint8) and returns the result.\\n     */\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint8 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint8 a, uint8) and returns the result.\\n     */\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint8 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint8 a, uint8) and returns the result.\\n     */\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint16 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint16 a, uint8) and returns the result.\\n     */\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint16 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint16 a, uint8) and returns the result.\\n     */\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint16 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint16 a, uint8) and returns the result.\\n     */\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint16 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint16 a, uint8) and returns the result.\\n     */\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint32 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint32 a, uint8) and returns the result.\\n     */\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint32 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint32 a, uint8) and returns the result.\\n     */\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint32 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint32 a, uint8) and returns the result.\\n     */\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint32 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint32 a, uint8) and returns the result.\\n     */\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint64 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint64 a, uint8) and returns the result.\\n     */\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint64 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint64 a, uint8) and returns the result.\\n     */\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint64 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint64 a, uint8) and returns the result.\\n     */\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint64 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint64 a, uint8) and returns the result.\\n     */\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint128 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint128 a, uint8) and returns the result.\\n     */\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint128 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint128 a, uint8) and returns the result.\\n     */\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint128 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint128 a, uint8) and returns the result.\\n     */\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint128 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint128 a, uint8) and returns the result.\\n     */\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint256 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint256 a, uint8) and returns the result.\\n     */\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint256 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint256 a, uint8) and returns the result.\\n     */\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint256 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint256 a, uint8) and returns the result.\\n     */\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint256 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint256 a, uint8) and returns the result.\\n     */\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint8'.\\n     */\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint8'.\\n     */\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint8'.\\n     */\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint8'.\\n     */\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint8'.\\n     */\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint8'.\\n     */\\n    function asEuint8(ebool b) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'ebool'.\\n     */\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint16'.\\n     */\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint16'.\\n     */\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint16'.\\n     */\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint16'.\\n     */\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint16'.\\n     */\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint16'.\\n     */\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'ebool'.\\n     */\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint32'.\\n     */\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint32'.\\n     */\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint32'.\\n     */\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint32'.\\n     */\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint32'.\\n     */\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint32'.\\n     */\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'ebool'.\\n     */\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint64'.\\n     */\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint64'.\\n     */\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint64'.\\n     */\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint64'.\\n     */\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint64'.\\n     */\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint64'.\\n     */\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'ebool'.\\n     */\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint128'.\\n     */\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint128'.\\n     */\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint128'.\\n     */\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint128'.\\n     */\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint128'.\\n     */\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint128'.\\n     */\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'ebool'.\\n     */\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint256'.\\n     */\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint256'.\\n     */\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint256'.\\n     */\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint256'.\\n     */\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint256'.\\n     */\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint256'.\\n     */\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'ebool'.\\n     */\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Evaluates not(ebool value) and returns the result.\\n     */\\n    function not(ebool value) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint8 value) and returns the result.\\n     */\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint8 value) and returns the result.\\n     */\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint16 value) and returns the result.\\n     */\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint16 value) and returns the result.\\n     */\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint32 value) and returns the result.\\n     */\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint32 value) and returns the result.\\n     */\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint64 value) and returns the result.\\n     */\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint64 value) and returns the result.\\n     */\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint128 value) and returns the result.\\n     */\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint128 value) and returns the result.\\n     */\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint256 value) and returns the result.\\n     */\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint256 value) and returns the result.\\n     */\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted ebool integer.\\n     */\\n    function fromExternal(externalEbool inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(externalEbool.unwrap(inputHandle), inputProof, FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Converts a plaintext boolean to an encrypted boolean.\\n     */\\n    function asEbool(bool value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value ? 1 : 0, FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n     */\\n    function fromExternal(externalEuint8 inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(externalEuint8.unwrap(inputHandle), inputProof, FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint8 integer.\\n     */\\n    function asEuint8(uint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n     */\\n    function fromExternal(externalEuint16 inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(externalEuint16.unwrap(inputHandle), inputProof, FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint16 integer.\\n     */\\n    function asEuint16(uint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n     */\\n    function fromExternal(externalEuint32 inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(externalEuint32.unwrap(inputHandle), inputProof, FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint32 integer.\\n     */\\n    function asEuint32(uint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n     */\\n    function fromExternal(externalEuint64 inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(externalEuint64.unwrap(inputHandle), inputProof, FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint64 integer.\\n     */\\n    function asEuint64(uint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n     */\\n    function fromExternal(externalEuint128 inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(externalEuint128.unwrap(inputHandle), inputProof, FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint128 integer.\\n     */\\n    function asEuint128(uint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted eaddress integer.\\n     */\\n    function fromExternal(externalEaddress inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(externalEaddress.unwrap(inputHandle), inputProof, FheType.Uint160));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted eaddress integer.\\n     */\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), FheType.Uint160));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n     */\\n    function fromExternal(externalEuint256 inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(externalEuint256.unwrap(inputHandle), inputProof, FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint256 integer.\\n     */\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev This function cleans the transient storage for the ACL (accounts) and the InputVerifier\\n     *      (input proofs).\\n     *      This could be useful for integration with Account Abstraction when bundling several\\n     *      UserOps calling the FHEVMExecutor.\\n     */\\n    function cleanTransientStorage() internal {\\n        Impl.cleanTransientStorageACL();\\n        Impl.cleanTransientStorageInputVerifier();\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(ebool value, address account) internal returns (ebool) {\\n        Impl.allow(ebool.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(ebool value) internal returns (ebool) {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(ebool value, address account) internal returns (ebool) {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(ebool value) internal returns (ebool) {\\n        Impl.makePubliclyDecryptable(ebool.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(ebool value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(ebool.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint8 value, address account) internal returns (euint8) {\\n        Impl.allow(euint8.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint8 value) internal returns (euint8) {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint8 value, address account) internal returns (euint8) {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint8 value) internal returns (euint8) {\\n        Impl.makePubliclyDecryptable(euint8.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint8 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint8.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint16 value, address account) internal returns (euint16) {\\n        Impl.allow(euint16.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint16 value) internal returns (euint16) {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint16 value, address account) internal returns (euint16) {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint16 value) internal returns (euint16) {\\n        Impl.makePubliclyDecryptable(euint16.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint16 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint16.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint32 value, address account) internal returns (euint32) {\\n        Impl.allow(euint32.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint32 value) internal returns (euint32) {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint32 value, address account) internal returns (euint32) {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint32 value) internal returns (euint32) {\\n        Impl.makePubliclyDecryptable(euint32.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint32 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint32.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint64 value, address account) internal returns (euint64) {\\n        Impl.allow(euint64.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint64 value) internal returns (euint64) {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint64 value, address account) internal returns (euint64) {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint64 value) internal returns (euint64) {\\n        Impl.makePubliclyDecryptable(euint64.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint64 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint64.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint128 value, address account) internal returns (euint128) {\\n        Impl.allow(euint128.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint128 value) internal returns (euint128) {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint128 value, address account) internal returns (euint128) {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint128 value) internal returns (euint128) {\\n        Impl.makePubliclyDecryptable(euint128.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint128 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint128.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(eaddress value, address account) internal returns (eaddress) {\\n        Impl.allow(eaddress.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(eaddress value) internal returns (eaddress) {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(eaddress value, address account) internal returns (eaddress) {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(eaddress value) internal returns (eaddress) {\\n        Impl.makePubliclyDecryptable(eaddress.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(eaddress value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(eaddress.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint256 value, address account) internal returns (euint256) {\\n        Impl.allow(euint256.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint256 value) internal returns (euint256) {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint256 value, address account) internal returns (euint256) {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint256 value) internal returns (euint256) {\\n        Impl.makePubliclyDecryptable(euint256.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint256 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint256.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Recovers the stored array of handles corresponding to requestID.\\n     */\\n    function loadRequestedHandles(uint256 requestID) internal view returns (bytes32[] memory) {\\n        DecryptionRequestsStruct storage $ = Impl.getDecryptionRequests();\\n        if ($.requestedHandles[requestID].length == 0) {\\n            revert NoHandleFoundForRequestID();\\n        }\\n        return $.requestedHandles[requestID];\\n    }\\n\\n    /**\\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles.\\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\\n     */\\n    function requestDecryption(\\n        bytes32[] memory ctsHandles,\\n        bytes4 callbackSelector\\n    ) internal returns (uint256 requestID) {\\n        requestID = requestDecryption(ctsHandles, callbackSelector, 0);\\n    }\\n\\n    /**\\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles, with a custom msgValue.\\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\\n     */\\n    function requestDecryption(\\n        bytes32[] memory ctsHandles,\\n        bytes4 callbackSelector,\\n        uint256 msgValue\\n    ) internal returns (uint256 requestID) {\\n        DecryptionRequestsStruct storage $ = Impl.getDecryptionRequests();\\n        requestID = $.counterRequest;\\n        FHEVMConfigStruct storage $$ = Impl.getFHEVMConfig();\\n        IACL($$.ACLAddress).allowForDecryption(ctsHandles);\\n        IDecryptionOracle($.DecryptionOracleAddress).requestDecryption{value: msgValue}(\\n            requestID,\\n            ctsHandles,\\n            callbackSelector\\n        );\\n        saveRequestedHandles(requestID, ctsHandles);\\n        $.counterRequest++;\\n    }\\n\\n    /**\\n     * @dev     MUST be called inside the callback function the dApp contract to verify the signatures,\\n     * @dev     otherwise fake decryption results could be submitted.\\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\\n     */\\n    function checkSignatures(uint256 requestID, bytes[] memory signatures) internal {\\n        bytes32[] memory handlesList = loadRequestedHandles(requestID);\\n        bool isVerified = verifySignatures(handlesList, signatures);\\n        if (!isVerified) {\\n            revert InvalidKMSSignatures();\\n        }\\n        emit DecryptionFulfilled(requestID);\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to link in storage an array of handles to its associated requestID.\\n     */\\n    function saveRequestedHandles(uint256 requestID, bytes32[] memory handlesList) private {\\n        DecryptionRequestsStruct storage $ = Impl.getDecryptionRequests();\\n        if ($.requestedHandles[requestID].length != 0) {\\n            revert HandlesAlreadySavedForRequestID();\\n        }\\n        $.requestedHandles[requestID] = handlesList;\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to extract the decryptedResult bytes array and verify the KMS signatures.\\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\\n     */\\n    function verifySignatures(bytes32[] memory handlesList, bytes[] memory signatures) private returns (bool) {\\n        uint256 start = 4 + 32; // start position after skipping the selector (4 bytes) and the first argument (index, 32 bytes)\\n        uint256 length = getSignedDataLength(handlesList);\\n        bytes memory decryptedResult = new bytes(length);\\n        assembly {\\n            calldatacopy(add(decryptedResult, 0x20), start, length) // Copy the relevant part of calldata to decryptedResult memory\\n        }\\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\\n        return\\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\\n                handlesList,\\n                decryptedResult,\\n                signatures\\n            );\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to compute the length of the decryptedResult bytes array.\\n     */\\n    function getSignedDataLength(bytes32[] memory handlesList) private pure returns (uint256) {\\n        uint256 handlesListlen = handlesList.length;\\n        uint256 signedDataLength;\\n        for (uint256 i = 0; i < handlesListlen; i++) {\\n            FheType typeCt = FheType(uint8(handlesList[i][30]));\\n            if (uint8(typeCt) < 9) {\\n                signedDataLength += 32;\\n            } else {\\n                revert UnsupportedHandleType();\\n            }\\n        }\\n        signedDataLength += 32; // add offset of signatures\\n        return signedDataLength;\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(ebool value) internal pure returns (bytes32 ct) {\\n        ct = ebool.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint8 value) internal pure returns (bytes32 ct) {\\n        ct = euint8.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint16 value) internal pure returns (bytes32 ct) {\\n        ct = euint16.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint32 value) internal pure returns (bytes32 ct) {\\n        ct = euint32.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint64 value) internal pure returns (bytes32 ct) {\\n        ct = euint64.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint128 value) internal pure returns (bytes32 ct) {\\n        ct = euint128.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(eaddress value) internal pure returns (bytes32 ct) {\\n        ct = eaddress.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint256 value) internal pure returns (bytes32 ct) {\\n        ct = euint256.unwrap(value);\\n    }\\n}\\n\",\"keccak256\":\"0xb2c27424f0fb955b4d55ba9584fcbb0f86be91a1136c548062b9b52148fc0724\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/FheType.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nenum FheType {\\n    Bool,\\n    Uint4,\\n    Uint8,\\n    Uint16,\\n    Uint32,\\n    Uint64,\\n    Uint128,\\n    Uint160,\\n    Uint256,\\n    Uint512,\\n    Uint1024,\\n    Uint2048,\\n    Uint2,\\n    Uint6,\\n    Uint10,\\n    Uint12,\\n    Uint14,\\n    Int2,\\n    Int4,\\n    Int6,\\n    Int8,\\n    Int10,\\n    Int12,\\n    Int14,\\n    Int16,\\n    Int32,\\n    Int64,\\n    Int128,\\n    Int160,\\n    Int256,\\n    AsciiString,\\n    Int512,\\n    Int1024,\\n    Int2048,\\n    Uint24,\\n    Uint40,\\n    Uint48,\\n    Uint56,\\n    Uint72,\\n    Uint80,\\n    Uint88,\\n    Uint96,\\n    Uint104,\\n    Uint112,\\n    Uint120,\\n    Uint136,\\n    Uint144,\\n    Uint152,\\n    Uint168,\\n    Uint176,\\n    Uint184,\\n    Uint192,\\n    Uint200,\\n    Uint208,\\n    Uint216,\\n    Uint224,\\n    Uint232,\\n    Uint240,\\n    Uint248,\\n    Int24,\\n    Int40,\\n    Int48,\\n    Int56,\\n    Int72,\\n    Int80,\\n    Int88,\\n    Int96,\\n    Int104,\\n    Int112,\\n    Int120,\\n    Int136,\\n    Int144,\\n    Int152,\\n    Int168,\\n    Int176,\\n    Int184,\\n    Int192,\\n    Int200,\\n    Int208,\\n    Int216,\\n    Int224,\\n    Int232,\\n    Int240,\\n    Int248\\n}\\n\",\"keccak256\":\"0x945f006108fab92cb082a6e5a80525953f17b8d8dcf88a283a83fc80c765497a\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {FheType} from \\\"./FheType.sol\\\";\\n\\n/**\\n * @title   FHEVMConfigStruct\\n * @notice  This struct contains all addresses of core contracts, which are needed in a typical dApp.\\n */\\nstruct FHEVMConfigStruct {\\n    address ACLAddress;\\n    address FHEVMExecutorAddress;\\n    address KMSVerifierAddress;\\n    address InputVerifierAddress;\\n}\\n\\n/**\\n * @title   DecryptionRequestsStruct\\n * @notice  This struct contains the address of the decryption oracle contract,\\n *          the internal counter for requestIDs generated by the dapp,\\n *          and the mapping from internal requestIDs to list of handles requested for decryption.\\n */\\nstruct DecryptionRequestsStruct {\\n    address DecryptionOracleAddress;\\n    uint256 counterRequest;\\n    mapping(uint256 => bytes32[]) requestedHandles;\\n}\\n\\n/**\\n * @title   IFHEVMExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface IFHEVMExecutor {\\n    /**\\n     * @notice              Computes fheAdd operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheSub operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMul operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheDiv operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRem operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitAnd operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitOr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitXor operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheShl operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheShr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRotl operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRotr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheEq operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheGe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheGt operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheLe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheLt operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMin operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMax operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNeg operation.\\n     * @param ct            Ct\\n     * @return result       Result.\\n     */\\n    function fheNeg(bytes32 ct) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNot operation.\\n     * @param ct            Ct\\n     * @return result       Result.\\n     */\\n    function fheNot(bytes32 ct) external returns (bytes32 result);\\n    /**\\n     * @notice                Verifies the ciphertext.\\n     * @param inputHandle     Input handle.\\n     * @param callerAddress   Address of the caller.\\n     * @param inputProof      Input proof.\\n     * @param inputType       Input type.\\n     * @return result         Result.\\n     */\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        FheType inputType\\n    ) external returns (bytes32 result);\\n\\n    /**\\n     * @notice          Performs the casting to a target type.\\n     * @param ct        Value to cast.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice          Does trivial encryption.\\n     * @param ct        Value to encrypt.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function trivialEncrypt(uint256 ct, FheType toType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHEIfThenElse operation.\\n     * @param control       Control value.\\n     * @param ifTrue        If true.\\n     * @param ifFalse       If false.\\n     * @return result       Result.\\n     */\\n    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHERand operation.\\n     * @param randType      Type for the random result.\\n     * @return result       Result.\\n     */\\n    function fheRand(FheType randType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHERandBounded operation.\\n     * @param upperBound    Upper bound value.\\n     * @param randType      Type for the random result.\\n     * @return result       Result.\\n     */\\n    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);\\n}\\n\\n/**\\n * @title   IACL.\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    /**\\n     * @notice              Allows the use of handle by address account for this transaction.\\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\\n     *                      If not, allowTransient() reverts.\\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\\n     * @param ciphertext    Ciphertext.\\n     * @param account       Address of the account.\\n     */\\n    function allowTransient(bytes32 ciphertext, address account) external;\\n\\n    /**\\n     * @notice              Allows the use of handle for the address account.\\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allow(bytes32 handle, address account) external;\\n\\n    /**\\n     * @dev This function removes the transient allowances, which could be useful for integration with\\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorage() external;\\n\\n    /**\\n     * @notice              Returns whether the account is allowed to use the handle, either due to\\n     *                      allowTransient() or allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     * @return isAllowed    Whether the account can access the handle.\\n     */\\n    function isAllowed(bytes32 handle, address account) external view returns (bool);\\n\\n    /**\\n     * @notice              Allows a list of handles to be decrypted.\\n     * @param handlesList   List of handles.\\n     */\\n    function allowForDecryption(bytes32[] memory handlesList) external;\\n\\n    /**\\n     * @notice                  Returns wether a handle is allowed to be publicly decrypted.\\n     * @param handle            Handle.\\n     * @return isDecryptable    Whether the handle can be publicly decrypted.\\n     */\\n    function isAllowedForDecryption(bytes32 handle) external view returns (bool);\\n}\\n\\n/**\\n * @title IInputVerifier\\n * @notice This interface contains the only function required from InputVerifier.\\n */\\ninterface IInputVerifier {\\n    /**\\n     * @dev This function removes the transient allowances, which could be useful for integration with\\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorage() external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.FHEVMConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\\n\\n    /// keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.DecryptionRequests\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant DecryptionRequestsStorageLocation =\\n        0x5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d00;\\n\\n    /**\\n     * @dev Returns the FHEVM config.\\n     */\\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\\n        assembly {\\n            $.slot := FHEVMConfigLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the DecryptionRequestsStruct storage struct.\\n     */\\n    function getDecryptionRequests() internal pure returns (DecryptionRequestsStruct storage $) {\\n        assembly {\\n            $.slot := DecryptionRequestsStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @notice            Sets the coprocessor addresses.\\n     * @param fhevmConfig FHEVM config struct that contains contract addresses.\\n     */\\n    function setCoprocessor(FHEVMConfigStruct memory fhevmConfig) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        $.ACLAddress = fhevmConfig.ACLAddress;\\n        $.FHEVMExecutorAddress = fhevmConfig.FHEVMExecutorAddress;\\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\\n        $.InputVerifierAddress = fhevmConfig.InputVerifierAddress;\\n    }\\n\\n    /**\\n     * @notice                 Sets the decryption oracle address.\\n     * @param decryptionOracle The decryption oracle address.\\n     */\\n    function setDecryptionOracle(address decryptionOracle) internal {\\n        DecryptionRequestsStruct storage $ = getDecryptionRequests();\\n        $.DecryptionOracleAddress = decryptionOracle;\\n    }\\n\\n    function add(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(bytes32 ct) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheNeg(ct);\\n    }\\n\\n    function not(bytes32 ct) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheNot(ct);\\n    }\\n\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    /**\\n     * @notice              Verifies the ciphertext (FHEVMExecutor) and allows transient (ACL).\\n     * @param inputHandle   Input handle.\\n     * @param inputProof    Input proof.\\n     * @param toType        Input type.\\n     * @return result       Result.\\n     */\\n    function verify(bytes32 inputHandle, bytes memory inputProof, FheType toType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).verifyCiphertext(inputHandle, msg.sender, inputProof, toType);\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    /**\\n     * @notice            Performs the casting to a target type.\\n     * @param ciphertext  Ciphertext to cast.\\n     * @param toType      Target type.\\n     * @return result     Result value of the target type.\\n     */\\n    function cast(bytes32 ciphertext, FheType toType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).cast(ciphertext, toType);\\n    }\\n\\n    /**\\n     * @notice          Does trivial encryption.\\n     * @param value     Value to encrypt.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function trivialEncrypt(uint256 value, FheType toType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).trivialEncrypt(value, toType);\\n    }\\n\\n    function rand(FheType randType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRand(randType);\\n    }\\n\\n    function randBounded(uint256 upperBound, FheType randType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRandBounded(upperBound, randType);\\n    }\\n\\n    /**\\n     * @notice              Allows the use of handle by address account for this transaction.\\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\\n     *                      If not, allowTransient() reverts.\\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allowTransient(bytes32 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Allows the use of handle for the address account.\\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allow(bytes32 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Allows the handle to be publicly decryptable.\\n     * @dev                 The caller must be allowed to use handle for makePubliclyDecryptable() to succeed.\\n     *                      If not, makePubliclyDecryptable() reverts.\\n     * @param handle        Handle.\\n     */\\n    function makePubliclyDecryptable(bytes32 handle) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        bytes32[] memory handleArray = new bytes32[](1);\\n        handleArray[0] = handle;\\n        IACL($.ACLAddress).allowForDecryption(handleArray);\\n    }\\n\\n    /**\\n     * @dev This function removes the transient allowances in the ACL, which could be useful for integration\\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorageACL() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    /**\\n     * @dev This function removes the transient proofs in the InputVerifier, which could be useful for integration\\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorageInputVerifier() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IInputVerifier($.InputVerifierAddress).cleanTransientStorage();\\n    }\\n\\n    /**\\n     * @notice              Returns whether the account is allowed to use the handle, either due to\\n     *                      allowTransient() or allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     * @return isAllowed    Whether the account can access the handle.\\n     */\\n    function isAllowed(bytes32 handle, address account) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Returns whether the handle is allowed to be publicly decrypted.\\n     * @param handle        Handle.\\n     * @return isAllowed    Whether the handle can be publicly decrypted.\\n     */\\n    function isPubliclyDecryptable(bytes32 handle) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowedForDecryption(handle);\\n    }\\n}\\n\",\"keccak256\":\"0xf4d58b67ea3f81a56c5c8a66ad9843631909b8c393b87e0b42a7a3eb3d5fedb8\",\"license\":\"BSD-3-Clause-Clear\"},\"@openzeppelin/confidential-contracts/interfaces/IConfidentialFungibleToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (interfaces/IConfidentialFungibleToken.sol)\\npragma solidity ^0.8.24;\\n\\nimport {euint64, externalEuint64} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\n\\n/// @dev Draft interface for a confidential fungible token standard utilizing the Zama FHE library.\\ninterface IConfidentialFungibleToken {\\n    /**\\n     * @dev Emitted when the expiration timestamp for an operator `operator` is updated for a given `holder`.\\n     * The operator may move any amount of tokens on behalf of the holder until the timestamp `until`.\\n     */\\n    event OperatorSet(address indexed holder, address indexed operator, uint48 until);\\n\\n    /// @dev Emitted when a confidential transfer is made from `from` to `to` of encrypted amount `amount`.\\n    event ConfidentialTransfer(address indexed from, address indexed to, euint64 indexed amount);\\n\\n    /**\\n     * @dev Emitted when an encrypted amount is disclosed.\\n     *\\n     * Accounts with access to the encrypted amount `encryptedAmount` that is also accessible to this contract\\n     * should be able to disclose the amount. This functionality is implementation specific.\\n     */\\n    event AmountDisclosed(euint64 indexed encryptedAmount, uint64 amount);\\n\\n    /// @dev Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @dev Returns the number of decimals of the token. Recommended to be 6.\\n    function decimals() external view returns (uint8);\\n\\n    /// @dev Returns the token URI.\\n    function tokenURI() external view returns (string memory);\\n\\n    /// @dev Returns the confidential total supply of the token.\\n    function confidentialTotalSupply() external view returns (euint64);\\n\\n    /// @dev Returns the confidential balance of the account `account`.\\n    function confidentialBalanceOf(address account) external view returns (euint64);\\n\\n    /// @dev Returns true if `spender` is currently an operator for `holder`.\\n    function isOperator(address holder, address spender) external view returns (bool);\\n\\n    /**\\n     * @dev Sets `operator` as an operator for `holder` until the timestamp `until`.\\n     *\\n     * NOTE: An operator may transfer any amount of tokens on behalf of a holder while approved.\\n     */\\n    function setOperator(address operator, uint48 until) external;\\n\\n    /**\\n     * @dev Transfers the encrypted amount `encryptedAmount` to `to` with the given input proof `inputProof`.\\n     *\\n     * Returns the encrypted amount that was actually transferred.\\n     */\\n    function confidentialTransfer(\\n        address to,\\n        externalEuint64 encryptedAmount,\\n        bytes calldata inputProof\\n    ) external returns (euint64);\\n\\n    /**\\n     * @dev Similar to {confidentialTransfer-address-externalEuint64-bytes} but without an input proof. The caller\\n     * *must* already be allowed by ACL for the given `amount`.\\n     */\\n    function confidentialTransfer(address to, euint64 amount) external returns (euint64 transferred);\\n\\n    /**\\n     * @dev Transfers the encrypted amount `encryptedAmount` from `from` to `to` with the given input proof\\n     * `inputProof`. `msg.sender` must be either `from` or an operator for `from`.\\n     *\\n     * Returns the encrypted amount that was actually transferred.\\n     */\\n    function confidentialTransferFrom(\\n        address from,\\n        address to,\\n        externalEuint64 encryptedAmount,\\n        bytes calldata inputProof\\n    ) external returns (euint64);\\n\\n    /**\\n     * @dev Similar to {confidentialTransferFrom-address-address-externalEuint64-bytes} but without an input proof.\\n     * The caller *must* be already allowed by ACL for the given `amount`.\\n     */\\n    function confidentialTransferFrom(address from, address to, euint64 amount) external returns (euint64 transferred);\\n\\n    /**\\n     * @dev Similar to {confidentialTransfer-address-externalEuint64-bytes} but with a callback to `to` after\\n     * the transfer.\\n     *\\n     * The callback is made to the {IConfidentialFungibleTokenReceiver-onConfidentialTransferReceived} function on the\\n     * to address with the actual transferred amount (may differ from the given `encryptedAmount`) and the given\\n     * data `data`.\\n     */\\n    function confidentialTransferAndCall(\\n        address to,\\n        externalEuint64 encryptedAmount,\\n        bytes calldata inputProof,\\n        bytes calldata data\\n    ) external returns (euint64 transferred);\\n\\n    /// @dev Similar to {confidentialTransfer-address-euint64} but with a callback to `to` after the transfer.\\n    function confidentialTransferAndCall(\\n        address to,\\n        euint64 amount,\\n        bytes calldata data\\n    ) external returns (euint64 transferred);\\n\\n    /**\\n     * @dev Similar to {confidentialTransferFrom-address-address-externalEuint64-bytes} but with a callback to `to`\\n     * after the transfer.\\n     */\\n    function confidentialTransferFromAndCall(\\n        address from,\\n        address to,\\n        externalEuint64 encryptedAmount,\\n        bytes calldata inputProof,\\n        bytes calldata data\\n    ) external returns (euint64 transferred);\\n\\n    /**\\n     * @dev Similar to {confidentialTransferFrom-address-address-euint64} but with a callback to `to`\\n     * after the transfer.\\n     *\\n     */\\n    function confidentialTransferFromAndCall(\\n        address from,\\n        address to,\\n        euint64 amount,\\n        bytes calldata data\\n    ) external returns (euint64 transferred);\\n}\\n\",\"keccak256\":\"0x32a83ef60bd9831b52325f9c4bedb216e93cdbf21303be774fe54c1efe461473\",\"license\":\"MIT\"},\"@openzeppelin/confidential-contracts/interfaces/IConfidentialFungibleTokenReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (interfaces/IConfidentialFungibleTokenReceiver.sol)\\npragma solidity ^0.8.24;\\n\\nimport {ebool, euint64} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\n\\n/// @dev Interface for contracts that can receive confidential token transfers with a callback.\\ninterface IConfidentialFungibleTokenReceiver {\\n    /**\\n     * @dev Called upon receiving a confidential token transfer. Returns an encrypted boolean indicating success\\n     * of the callback. If false is returned, the transfer must be reversed.\\n     */\\n    function onConfidentialTransferReceived(\\n        address operator,\\n        address from,\\n        euint64 amount,\\n        bytes calldata data\\n    ) external returns (ebool);\\n}\\n\",\"keccak256\":\"0x7d63676a2a115fc2e991587616f8da9ab6714a6ef56d22cb6b417907856c3c97\",\"license\":\"MIT\"},\"@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (token/ConfidentialFungibleToken.sol)\\npragma solidity ^0.8.27;\\n\\nimport {FHE, externalEuint64, ebool, euint64} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\nimport {IConfidentialFungibleToken} from \\\"./../interfaces/IConfidentialFungibleToken.sol\\\";\\nimport {FHESafeMath} from \\\"./../utils/FHESafeMath.sol\\\";\\nimport {ConfidentialFungibleTokenUtils} from \\\"./utils/ConfidentialFungibleTokenUtils.sol\\\";\\n\\n/**\\n * @dev Reference implementation for {IConfidentialFungibleToken}.\\n *\\n * This contract implements a fungible token where balances and transfers are encrypted using the Zama fhEVM,\\n * providing confidentiality to users. Token amounts are stored as encrypted, unsigned integers (`euint64`)\\n * that can only be decrypted by authorized parties.\\n *\\n * Key features:\\n *\\n * - All balances are encrypted\\n * - Transfers happen without revealing amounts\\n * - Support for operators (delegated transfer capabilities with time bounds)\\n * - Transfer and call pattern\\n * - Safe overflow/underflow handling for FHE operations\\n */\\nabstract contract ConfidentialFungibleToken is IConfidentialFungibleToken {\\n    mapping(address holder => euint64) private _balances;\\n    mapping(address holder => mapping(address spender => uint48)) private _operators;\\n    mapping(uint256 requestId => euint64 encryptedAmount) private _requestHandles;\\n    euint64 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n    string private _tokenURI;\\n\\n    /// @dev The given receiver `receiver` is invalid for transfers.\\n    error ConfidentialFungibleTokenInvalidReceiver(address receiver);\\n\\n    /// @dev The given sender `sender` is invalid for transfers.\\n    error ConfidentialFungibleTokenInvalidSender(address sender);\\n\\n    /// @dev The given holder `holder` is not authorized to spend on behalf of `spender`.\\n    error ConfidentialFungibleTokenUnauthorizedSpender(address holder, address spender);\\n\\n    /// @dev The holder `holder` is trying to send tokens but has a balance of 0.\\n    error ConfidentialFungibleTokenZeroBalance(address holder);\\n\\n    /**\\n     * @dev The caller `user` does not have access to the encrypted amount `amount`.\\n     *\\n     * NOTE: Try using the equivalent transfer function with an input proof.\\n     */\\n    error ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(euint64 amount, address user);\\n\\n    /// @dev The given caller `caller` is not authorized for the current operation.\\n    error ConfidentialFungibleTokenUnauthorizedCaller(address caller);\\n\\n    /// @dev The given gateway request ID `requestId` is invalid.\\n    error ConfidentialFungibleTokenInvalidGatewayRequest(uint256 requestId);\\n\\n    constructor(string memory name_, string memory symbol_, string memory tokenURI_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _tokenURI = tokenURI_;\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function decimals() public view virtual returns (uint8) {\\n        return 6;\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function tokenURI() public view virtual returns (string memory) {\\n        return _tokenURI;\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTotalSupply() public view virtual returns (euint64) {\\n        return _totalSupply;\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialBalanceOf(address account) public view virtual returns (euint64) {\\n        return _balances[account];\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function isOperator(address holder, address spender) public view virtual returns (bool) {\\n        return holder == spender || block.timestamp <= _operators[holder][spender];\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function setOperator(address operator, uint48 until) public virtual {\\n        _setOperator(msg.sender, operator, until);\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTransfer(\\n        address to,\\n        externalEuint64 encryptedAmount,\\n        bytes calldata inputProof\\n    ) public virtual returns (euint64) {\\n        return _transfer(msg.sender, to, FHE.fromExternal(encryptedAmount, inputProof));\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTransfer(address to, euint64 amount) public virtual returns (euint64) {\\n        require(\\n            FHE.isAllowed(amount, msg.sender),\\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(amount, msg.sender)\\n        );\\n        return _transfer(msg.sender, to, amount);\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTransferFrom(\\n        address from,\\n        address to,\\n        externalEuint64 encryptedAmount,\\n        bytes calldata inputProof\\n    ) public virtual returns (euint64 transferred) {\\n        require(isOperator(from, msg.sender), ConfidentialFungibleTokenUnauthorizedSpender(from, msg.sender));\\n        transferred = _transfer(from, to, FHE.fromExternal(encryptedAmount, inputProof));\\n        FHE.allowTransient(transferred, msg.sender);\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTransferFrom(\\n        address from,\\n        address to,\\n        euint64 amount\\n    ) public virtual returns (euint64 transferred) {\\n        require(\\n            FHE.isAllowed(amount, msg.sender),\\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(amount, msg.sender)\\n        );\\n        require(isOperator(from, msg.sender), ConfidentialFungibleTokenUnauthorizedSpender(from, msg.sender));\\n        transferred = _transfer(from, to, amount);\\n        FHE.allowTransient(transferred, msg.sender);\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTransferAndCall(\\n        address to,\\n        externalEuint64 encryptedAmount,\\n        bytes calldata inputProof,\\n        bytes calldata data\\n    ) public virtual returns (euint64 transferred) {\\n        transferred = _transferAndCall(msg.sender, to, FHE.fromExternal(encryptedAmount, inputProof), data);\\n        FHE.allowTransient(transferred, msg.sender);\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTransferAndCall(\\n        address to,\\n        euint64 amount,\\n        bytes calldata data\\n    ) public virtual returns (euint64 transferred) {\\n        require(\\n            FHE.isAllowed(amount, msg.sender),\\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(amount, msg.sender)\\n        );\\n        transferred = _transferAndCall(msg.sender, to, amount, data);\\n        FHE.allowTransient(transferred, msg.sender);\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTransferFromAndCall(\\n        address from,\\n        address to,\\n        externalEuint64 encryptedAmount,\\n        bytes calldata inputProof,\\n        bytes calldata data\\n    ) public virtual returns (euint64 transferred) {\\n        require(isOperator(from, msg.sender), ConfidentialFungibleTokenUnauthorizedSpender(from, msg.sender));\\n        transferred = _transferAndCall(from, to, FHE.fromExternal(encryptedAmount, inputProof), data);\\n        FHE.allowTransient(transferred, msg.sender);\\n    }\\n\\n    /// @inheritdoc IConfidentialFungibleToken\\n    function confidentialTransferFromAndCall(\\n        address from,\\n        address to,\\n        euint64 amount,\\n        bytes calldata data\\n    ) public virtual returns (euint64 transferred) {\\n        require(\\n            FHE.isAllowed(amount, msg.sender),\\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(amount, msg.sender)\\n        );\\n        require(isOperator(from, msg.sender), ConfidentialFungibleTokenUnauthorizedSpender(from, msg.sender));\\n        transferred = _transferAndCall(from, to, amount, data);\\n        FHE.allowTransient(transferred, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Discloses an encrypted amount `encryptedAmount` publicly via an {IConfidentialFungibleToken-AmountDisclosed}\\n     * event. The caller and this contract must be authorized to use the encrypted amount on the ACL.\\n     *\\n     * NOTE: This is an asynchronous operation where the actual decryption happens off-chain and\\n     * {finalizeDiscloseEncryptedAmount} is called with the result.\\n     */\\n    function discloseEncryptedAmount(euint64 encryptedAmount) public virtual {\\n        require(\\n            FHE.isAllowed(encryptedAmount, msg.sender) && FHE.isAllowed(encryptedAmount, address(this)),\\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(encryptedAmount, msg.sender)\\n        );\\n\\n        bytes32[] memory cts = new bytes32[](1);\\n        cts[0] = euint64.unwrap(encryptedAmount);\\n        uint256 requestID = FHE.requestDecryption(cts, this.finalizeDiscloseEncryptedAmount.selector);\\n        _requestHandles[requestID] = encryptedAmount;\\n    }\\n\\n    /// @dev Finalizes a disclose encrypted amount request.\\n    function finalizeDiscloseEncryptedAmount(\\n        uint256 requestId,\\n        uint64 amount,\\n        bytes[] memory signatures\\n    ) public virtual {\\n        FHE.checkSignatures(requestId, signatures);\\n\\n        euint64 requestHandle = _requestHandles[requestId];\\n        require(FHE.isInitialized(requestHandle), ConfidentialFungibleTokenInvalidGatewayRequest(requestId));\\n        emit AmountDisclosed(requestHandle, amount);\\n\\n        _requestHandles[requestId] = euint64.wrap(0);\\n    }\\n\\n    function _setOperator(address holder, address operator, uint48 until) internal virtual {\\n        _operators[holder][operator] = until;\\n        emit OperatorSet(holder, operator, until);\\n    }\\n\\n    function _mint(address to, euint64 amount) internal returns (euint64 transferred) {\\n        require(to != address(0), ConfidentialFungibleTokenInvalidReceiver(address(0)));\\n        return _update(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, euint64 amount) internal returns (euint64 transferred) {\\n        require(from != address(0), ConfidentialFungibleTokenInvalidSender(address(0)));\\n        return _update(from, address(0), amount);\\n    }\\n\\n    function _transfer(address from, address to, euint64 amount) internal returns (euint64 transferred) {\\n        require(from != address(0), ConfidentialFungibleTokenInvalidSender(address(0)));\\n        require(to != address(0), ConfidentialFungibleTokenInvalidReceiver(address(0)));\\n        return _update(from, to, amount);\\n    }\\n\\n    function _transferAndCall(\\n        address from,\\n        address to,\\n        euint64 amount,\\n        bytes calldata data\\n    ) internal returns (euint64 transferred) {\\n        // Try to transfer amount + replace input with actually transferred amount.\\n        euint64 sent = _transfer(from, to, amount);\\n\\n        // Perform callback\\n        ebool success = ConfidentialFungibleTokenUtils.checkOnTransferReceived(msg.sender, from, to, sent, data);\\n\\n        // Try to refund if callback fails\\n        euint64 refund = _update(to, from, FHE.select(success, FHE.asEuint64(0), sent));\\n        transferred = FHE.sub(sent, refund);\\n    }\\n\\n    function _update(address from, address to, euint64 amount) internal virtual returns (euint64 transferred) {\\n        ebool success;\\n        euint64 ptr;\\n\\n        if (from == address(0)) {\\n            (success, ptr) = FHESafeMath.tryIncrease(_totalSupply, amount);\\n            FHE.allowThis(ptr);\\n            _totalSupply = ptr;\\n        } else {\\n            euint64 fromBalance = _balances[from];\\n            require(FHE.isInitialized(fromBalance), ConfidentialFungibleTokenZeroBalance(from));\\n            (success, ptr) = FHESafeMath.tryDecrease(fromBalance, amount);\\n            FHE.allowThis(ptr);\\n            FHE.allow(ptr, from);\\n            _balances[from] = ptr;\\n        }\\n\\n        transferred = FHE.select(success, amount, FHE.asEuint64(0));\\n\\n        if (to == address(0)) {\\n            ptr = FHE.sub(_totalSupply, transferred);\\n            FHE.allowThis(ptr);\\n            _totalSupply = ptr;\\n        } else {\\n            ptr = FHE.add(_balances[to], transferred);\\n            FHE.allowThis(ptr);\\n            FHE.allow(ptr, to);\\n            _balances[to] = ptr;\\n        }\\n\\n        if (from != address(0)) FHE.allow(transferred, from);\\n        if (to != address(0)) FHE.allow(transferred, to);\\n        FHE.allowThis(transferred);\\n        emit ConfidentialTransfer(from, to, transferred);\\n    }\\n}\\n\",\"keccak256\":\"0xe77a52817f9326fe8efdf43b5a7e5077038739f8e312a6a0a8e63c817e5b67b6\",\"license\":\"MIT\"},\"@openzeppelin/confidential-contracts/token/utils/ConfidentialFungibleTokenUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (token/utils/ConfidentialFungibleTokenUtils.sol)\\npragma solidity ^0.8.24;\\n\\nimport {FHE, ebool, euint64} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\n\\nimport {IConfidentialFungibleTokenReceiver} from \\\"../../interfaces/IConfidentialFungibleTokenReceiver.sol\\\";\\nimport {ConfidentialFungibleToken} from \\\"../ConfidentialFungibleToken.sol\\\";\\n\\n/// @dev Library that provides common {ConfidentialFungibleToken} utility functions.\\nlibrary ConfidentialFungibleTokenUtils {\\n    /**\\n     * @dev Performs a transfer callback to the recipient of the transfer `to`. Should be invoked\\n     * after all transfers \\\"withCallback\\\" on a {ConfidentialFungibleToken}.\\n     *\\n     * The transfer callback is not invoked on the recipient if the recipient has no code (i.e. is an EOA). If the\\n     * recipient has non-zero code, it must implement\\n     * {IConfidentialFungibleTokenReceiver-onConfidentialTransferReceived} and return an `ebool` indicating\\n     * whether the transfer was accepted or not. If the `ebool` is `false`, the transfer will be reversed.\\n     */\\n    function checkOnTransferReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        euint64 amount,\\n        bytes calldata data\\n    ) internal returns (ebool) {\\n        if (to.code.length > 0) {\\n            try\\n                IConfidentialFungibleTokenReceiver(to).onConfidentialTransferReceived(operator, from, amount, data)\\n            returns (ebool retval) {\\n                return retval;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert ConfidentialFungibleToken.ConfidentialFungibleTokenInvalidReceiver(to);\\n                } else {\\n                    assembly (\\\"memory-safe\\\") {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return FHE.asEbool(true);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaad7ec8df1342570675fcc1359d25e60cce2785ebc7affef3a8760297b35fb58\",\"license\":\"MIT\"},\"@openzeppelin/confidential-contracts/utils/FHESafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (utils/FHESafeMath.sol)\\npragma solidity ^0.8.24;\\n\\nimport {FHE, ebool, euint64} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\n\\n/**\\n * @dev Library providing safe arithmetic operations for encrypted values\\n * to handle potential overflows in FHE operations.\\n */\\nlibrary FHESafeMath {\\n    /**\\n     * @dev Try to increase the encrypted value `oldValue` by `delta`. If the operation is successful,\\n     * `success` will be true and `updated` will be the new value. Otherwise, `success` will be false\\n     * and `updated` will be the original value.\\n     */\\n    function tryIncrease(euint64 oldValue, euint64 delta) internal returns (ebool success, euint64 updated) {\\n        if (!FHE.isInitialized(oldValue)) {\\n            success = FHE.asEbool(true);\\n            updated = delta;\\n        } else {\\n            euint64 newValue = FHE.add(oldValue, delta);\\n            success = FHE.ge(newValue, oldValue);\\n            updated = FHE.select(success, newValue, oldValue);\\n        }\\n    }\\n\\n    /**\\n     * @dev Try to decrease the encrypted value `oldValue` by `delta`. If the operation is successful,\\n     * `success` will be true and `updated` will be the new value. Otherwise, `success` will be false\\n     * and `updated` will be the original value.\\n     */\\n    function tryDecrease(euint64 oldValue, euint64 delta) internal returns (ebool success, euint64 updated) {\\n        success = FHE.ge(oldValue, delta);\\n        updated = FHE.select(success, FHE.sub(oldValue, delta), oldValue);\\n    }\\n}\\n\",\"keccak256\":\"0x53790876e941796c2b716e3741bf7a513fc0795d999a362316d0f6b90053af8b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/ConfidentialWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {ConfidentialFungibleToken} from \\\"@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol\\\";\\n/* SepoliaConfig removed to avoid compile-time config dependency */\\nimport {FHE, euint32, euint64, externalEuint32, ebool} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {FHESafeMath} from \\\"@openzeppelin/confidential-contracts/utils/FHESafeMath.sol\\\";\\n\\n/// @title Confidential WETH (cWETH)\\n/// @notice ERC7984 implementation for confidential WETH with wrap/unwrap functionality\\n/// @dev This contract allows users to wrap ETH into confidential WETH tokens\\ncontract ConfidentialWETH is ConfidentialFungibleToken, Ownable {\\n    // Events - CONFIDENTIAL: No plaintext amounts exposed\\n    event ConfidentialDeposit(address indexed user);\\n    event ConfidentialWithdrawal(address indexed user);\\n    event ConfidentialWrap(address indexed user);\\n    event ConfidentialUnwrap(address indexed user);\\n\\n    // Mapping to store encrypted balances\\n    mapping(address => euint64) private _encryptedBalances;\\n    \\n    // Total supply tracking (encrypted)\\n    euint64 private _totalSupply;\\n\\n    constructor() ConfidentialFungibleToken(\\\"Confidential Wrapped Ether\\\", \\\"cWETH\\\", \\\"https://api.example.com/metadata/\\\") Ownable(msg.sender) {}\\n\\n    /// @notice Wrap ETH into confidential WETH\\n    /// @dev Users send ETH and receive encrypted cWETH tokens\\n    /// @dev CONFIDENTIAL: No plaintext amounts are exposed\\n    function wrap() external payable {\\n        require(msg.value > 0, \\\"ConfidentialWETH: Cannot wrap 0 ETH\\\");\\n        \\n        // Convert ETH amount to encrypted value\\n        euint64 encryptedAmount = FHE.asEuint64(uint64(msg.value));\\n        \\n        // Update encrypted balance\\n        _encryptedBalances[msg.sender] = FHE.add(_encryptedBalances[msg.sender], encryptedAmount);\\n        \\n        // Update total supply\\n        _totalSupply = FHE.add(_totalSupply, encryptedAmount);\\n        \\n        // Allow contract and user to access the encrypted balance\\n        FHE.allowThis(_encryptedBalances[msg.sender]);\\n        FHE.allow(_encryptedBalances[msg.sender], msg.sender);\\n        FHE.allowThis(_totalSupply);\\n        \\n        // Emit CONFIDENTIAL event (no amounts exposed)\\n        emit ConfidentialWrap(msg.sender);\\n    }\\n\\n    /// @notice Get encrypted balance of a user\\n    /// @param user The user address\\n    /// @return The encrypted balance\\n    function getEncryptedBalance(address user) external view returns (euint64) {\\n        return _encryptedBalances[user];\\n    }\\n\\n    /// @notice Get encrypted total supply\\n    /// @return The encrypted total supply\\n    function getEncryptedTotalSupply() external view returns (euint64) {\\n        return _totalSupply;\\n    }\\n\\n    /// @notice Emergency function to withdraw ETH (only owner)\\n    /// @dev This function should only be used in emergency situations\\n    function emergencyWithdraw() external onlyOwner {\\n        uint256 balance = address(this).balance;\\n        require(balance > 0, \\\"ConfidentialWETH: No ETH to withdraw\\\");\\n        \\n        (bool success, ) = owner().call{value: balance}(\\\"\\\");\\n        require(success, \\\"ConfidentialWETH: Emergency withdrawal failed\\\");\\n    }\\n\\n    /// @notice Receive function to accept ETH deposits\\n    /// @dev CONFIDENTIAL: No plaintext amounts are exposed\\n    receive() external payable {\\n        emit ConfidentialDeposit(msg.sender);\\n    }\\n\\n    /// @notice Override _update to use our custom _encryptedBalances mapping\\n    /// @dev This ensures that transfers use our custom balance storage\\n    function _update(address from, address to, euint64 amount) internal override returns (euint64 transferred) {\\n        ebool success;\\n        euint64 ptr;\\n\\n        if (from == address(0)) {\\n            // Minting - increase total supply\\n            (success, ptr) = FHESafeMath.tryIncrease(_totalSupply, amount);\\n            FHE.allowThis(ptr);\\n            _totalSupply = ptr;\\n        } else {\\n            // Transfer from existing balance\\n            euint64 fromBalance = _encryptedBalances[from];\\n            require(FHE.isInitialized(fromBalance), ConfidentialFungibleTokenZeroBalance(from));\\n            (success, ptr) = FHESafeMath.tryDecrease(fromBalance, amount);\\n            FHE.allowThis(ptr);\\n            FHE.allow(ptr, from);\\n            _encryptedBalances[from] = ptr;\\n        }\\n\\n        transferred = FHE.select(success, amount, FHE.asEuint64(0));\\n\\n        if (to == address(0)) {\\n            // Burning - decrease total supply\\n            ptr = FHE.sub(_totalSupply, transferred);\\n            FHE.allowThis(ptr);\\n            _totalSupply = ptr;\\n        } else {\\n            // Transfer to recipient\\n            euint64 toBalance = _encryptedBalances[to];\\n            (success, ptr) = FHESafeMath.tryIncrease(toBalance, transferred);\\n            FHE.allowThis(ptr);\\n            FHE.allow(ptr, to);\\n            _encryptedBalances[to] = ptr;\\n        }\\n\\n        return transferred;\\n    }\\n}\",\"keccak256\":\"0x7971fa1ac26e6fbddb0d3d92d0cb09ec4244b91b2cf0c9828ac18a29ccff7aa3\",\"license\":\"MIT\"},\"encrypted-types/EncryptedTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ntype ebool is bytes32;\\n\\ntype euint8 is bytes32;\\ntype euint16 is bytes32;\\ntype euint24 is bytes32;\\ntype euint32 is bytes32;\\ntype euint40 is bytes32;\\ntype euint48 is bytes32;\\ntype euint56 is bytes32;\\ntype euint64 is bytes32;\\ntype euint72 is bytes32;\\ntype euint80 is bytes32;\\ntype euint88 is bytes32;\\ntype euint96 is bytes32;\\ntype euint104 is bytes32;\\ntype euint112 is bytes32;\\ntype euint120 is bytes32;\\ntype euint128 is bytes32;\\ntype euint136 is bytes32;\\ntype euint144 is bytes32;\\ntype euint152 is bytes32;\\ntype euint160 is bytes32;\\ntype euint168 is bytes32;\\ntype euint176 is bytes32;\\ntype euint184 is bytes32;\\ntype euint192 is bytes32;\\ntype euint200 is bytes32;\\ntype euint208 is bytes32;\\ntype euint216 is bytes32;\\ntype euint224 is bytes32;\\ntype euint232 is bytes32;\\ntype euint240 is bytes32;\\ntype euint248 is bytes32;\\ntype euint256 is bytes32;\\n\\ntype eint8 is bytes32;\\ntype eint16 is bytes32;\\ntype eint24 is bytes32;\\ntype eint32 is bytes32;\\ntype eint40 is bytes32;\\ntype eint48 is bytes32;\\ntype eint56 is bytes32;\\ntype eint64 is bytes32;\\ntype eint72 is bytes32;\\ntype eint80 is bytes32;\\ntype eint88 is bytes32;\\ntype eint96 is bytes32;\\ntype eint104 is bytes32;\\ntype eint112 is bytes32;\\ntype eint120 is bytes32;\\ntype eint128 is bytes32;\\ntype eint136 is bytes32;\\ntype eint144 is bytes32;\\ntype eint152 is bytes32;\\ntype eint160 is bytes32;\\ntype eint168 is bytes32;\\ntype eint176 is bytes32;\\ntype eint184 is bytes32;\\ntype eint192 is bytes32;\\ntype eint200 is bytes32;\\ntype eint208 is bytes32;\\ntype eint216 is bytes32;\\ntype eint224 is bytes32;\\ntype eint232 is bytes32;\\ntype eint240 is bytes32;\\ntype eint248 is bytes32;\\ntype eint256 is bytes32;\\n\\ntype eaddress is bytes32;\\n\\ntype ebytes1 is bytes32;\\ntype ebytes2 is bytes32;\\ntype ebytes3 is bytes32;\\ntype ebytes4 is bytes32;\\ntype ebytes5 is bytes32;\\ntype ebytes6 is bytes32;\\ntype ebytes7 is bytes32;\\ntype ebytes8 is bytes32;\\ntype ebytes9 is bytes32;\\ntype ebytes10 is bytes32;\\ntype ebytes11 is bytes32;\\ntype ebytes12 is bytes32;\\ntype ebytes13 is bytes32;\\ntype ebytes14 is bytes32;\\ntype ebytes15 is bytes32;\\ntype ebytes16 is bytes32;\\ntype ebytes17 is bytes32;\\ntype ebytes18 is bytes32;\\ntype ebytes19 is bytes32;\\ntype ebytes20 is bytes32;\\ntype ebytes21 is bytes32;\\ntype ebytes22 is bytes32;\\ntype ebytes23 is bytes32;\\ntype ebytes24 is bytes32;\\ntype ebytes25 is bytes32;\\ntype ebytes26 is bytes32;\\ntype ebytes27 is bytes32;\\ntype ebytes28 is bytes32;\\ntype ebytes29 is bytes32;\\ntype ebytes30 is bytes32;\\ntype ebytes31 is bytes32;\\ntype ebytes32 is bytes32;\\n\\ntype externalEbool is bytes32;\\n\\ntype externalEuint8 is bytes32;\\ntype externalEuint16 is bytes32;\\ntype externalEuint24 is bytes32;\\ntype externalEuint32 is bytes32;\\ntype externalEuint40 is bytes32;\\ntype externalEuint48 is bytes32;\\ntype externalEuint56 is bytes32;\\ntype externalEuint64 is bytes32;\\ntype externalEuint72 is bytes32;\\ntype externalEuint80 is bytes32;\\ntype externalEuint88 is bytes32;\\ntype externalEuint96 is bytes32;\\ntype externalEuint104 is bytes32;\\ntype externalEuint112 is bytes32;\\ntype externalEuint120 is bytes32;\\ntype externalEuint128 is bytes32;\\ntype externalEuint136 is bytes32;\\ntype externalEuint144 is bytes32;\\ntype externalEuint152 is bytes32;\\ntype externalEuint160 is bytes32;\\ntype externalEuint168 is bytes32;\\ntype externalEuint176 is bytes32;\\ntype externalEuint184 is bytes32;\\ntype externalEuint192 is bytes32;\\ntype externalEuint200 is bytes32;\\ntype externalEuint208 is bytes32;\\ntype externalEuint216 is bytes32;\\ntype externalEuint224 is bytes32;\\ntype externalEuint232 is bytes32;\\ntype externalEuint240 is bytes32;\\ntype externalEuint248 is bytes32;\\ntype externalEuint256 is bytes32;\\n\\ntype externalEint8 is bytes32;\\ntype externalEint16 is bytes32;\\ntype externalEint24 is bytes32;\\ntype externalEint32 is bytes32;\\ntype externalEint40 is bytes32;\\ntype externalEint48 is bytes32;\\ntype externalEint56 is bytes32;\\ntype externalEint64 is bytes32;\\ntype externalEint72 is bytes32;\\ntype externalEint80 is bytes32;\\ntype externalEint88 is bytes32;\\ntype externalEint96 is bytes32;\\ntype externalEint104 is bytes32;\\ntype externalEint112 is bytes32;\\ntype externalEint120 is bytes32;\\ntype externalEint128 is bytes32;\\ntype externalEint136 is bytes32;\\ntype externalEint144 is bytes32;\\ntype externalEint152 is bytes32;\\ntype externalEint160 is bytes32;\\ntype externalEint168 is bytes32;\\ntype externalEint176 is bytes32;\\ntype externalEint184 is bytes32;\\ntype externalEint192 is bytes32;\\ntype externalEint200 is bytes32;\\ntype externalEint208 is bytes32;\\ntype externalEint216 is bytes32;\\ntype externalEint224 is bytes32;\\ntype externalEint232 is bytes32;\\ntype externalEint240 is bytes32;\\ntype externalEint248 is bytes32;\\ntype externalEint256 is bytes32;\\n\\ntype externalEaddress is bytes32;\\n\\ntype externalEbytes1 is bytes32;\\ntype externalEbytes2 is bytes32;\\ntype externalEbytes3 is bytes32;\\ntype externalEbytes4 is bytes32;\\ntype externalEbytes5 is bytes32;\\ntype externalEbytes6 is bytes32;\\ntype externalEbytes7 is bytes32;\\ntype externalEbytes8 is bytes32;\\ntype externalEbytes9 is bytes32;\\ntype externalEbytes10 is bytes32;\\ntype externalEbytes11 is bytes32;\\ntype externalEbytes12 is bytes32;\\ntype externalEbytes13 is bytes32;\\ntype externalEbytes14 is bytes32;\\ntype externalEbytes15 is bytes32;\\ntype externalEbytes16 is bytes32;\\ntype externalEbytes17 is bytes32;\\ntype externalEbytes18 is bytes32;\\ntype externalEbytes19 is bytes32;\\ntype externalEbytes20 is bytes32;\\ntype externalEbytes21 is bytes32;\\ntype externalEbytes22 is bytes32;\\ntype externalEbytes23 is bytes32;\\ntype externalEbytes24 is bytes32;\\ntype externalEbytes25 is bytes32;\\ntype externalEbytes26 is bytes32;\\ntype externalEbytes27 is bytes32;\\ntype externalEbytes28 is bytes32;\\ntype externalEbytes29 is bytes32;\\ntype externalEbytes30 is bytes32;\\ntype externalEbytes31 is bytes32;\\ntype externalEbytes32 is bytes32;\\n\",\"keccak256\":\"0x5da9799cd5c30067ea946164722197151baee1f2579a76f01874d4fb25df02a3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561000f575f5ffd5b50336040518060400160405280601a81526020017f436f6e666964656e7469616c2057726170706564204574686572000000000000815250604051806040016040528060058152602001640c6ae8aa8960db1b81525060405180606001604052806021815260200161281260219139600461008a84826101ce565b50600561009783826101ce565b5060066100a482826101ce565b5050506001600160a01b03821690506100d657604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b6100df816100e5565b50610288565b600780546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b634e487b7160e01b5f52604160045260245ffd5b600181811c9082168061015e57607f821691505b60208210810361017c57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156101c957805f5260205f20601f840160051c810160208510156101a75750805b601f840160051c820191505b818110156101c6575f81556001016101b3565b50505b505050565b81516001600160401b038111156101e7576101e7610136565b6101fb816101f5845461014a565b84610182565b6020601f82116001811461022d575f83156102165750848201515b5f19600385901b1c1916600184901b1784556101c6565b5f84815260208120601f198516915b8281101561025c578785015182556020948501946001909201910161023c565b508482101561027957868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b61257d806102955f395ff3fe608060405260043610610191575f3560e01c80638da5cb5b116100dc578063d4ea066411610087578063de64211911610062578063de64211914610451578063e064b9bb14610470578063eb3155b51461048f578063f2fde38b146104ae575f5ffd5b8063d4ea06641461040a578063d4febb961461041e578063db2e21bc1461043d575f5ffd5b8063c535803c116100b7578063c535803c146103c4578063c7b8a75e146103e3578063d46eb11914610402575f5ffd5b80638da5cb5b1461035a57806395d89b4114610381578063b6363cf214610395575f5ffd5b8063402dc4e41161013c5780635bebed7e116101175780635bebed7e14610306578063715018a6146103255780637279e2641461033b575f5ffd5b8063402dc4e41461029f578063537d3c50146102d357806354095227146102f2575f5ffd5b8063344ff1011161016c578063344ff1011461023857806334c457431461026c5780633c130d901461028b575f5ffd5b806306fdde03146101c65780632fb74e62146101f0578063313ce5671461021d575f5ffd5b366101c25760405133907fa5e14a44e1a528a28e895b7dc9df2e48d8717f0515104e15fefc03ad7401f561905f90a2005b5f5ffd5b3480156101d1575f5ffd5b506101da6104cd565b6040516101e79190611dd9565b60405180910390f35b3480156101fb575f5ffd5b5061020f61020a366004611e44565b61055d565b6040519081526020016101e7565b348015610228575f5ffd5b50604051600681526020016101e7565b348015610243575f5ffd5b5061020f610252366004611e9a565b6001600160a01b03165f9081526020819052604090205490565b348015610277575f5ffd5b5061020f610286366004611eb3565b6105b0565b348015610296575f5ffd5b506101da610659565b3480156102aa575f5ffd5b5061020f6102b9366004611e9a565b6001600160a01b03165f9081526008602052604090205490565b3480156102de575f5ffd5b5061020f6102ed366004611e44565b610668565b3480156102fd575f5ffd5b5060035461020f565b348015610311575f5ffd5b5061020f610320366004611f4c565b6106ca565b348015610330575f5ffd5b5061033961071e565b005b348015610346575f5ffd5b50610339610355366004611fb9565b610731565b348015610365575f5ffd5b506007546040516001600160a01b0390911681526020016101e7565b34801561038c575f5ffd5b506101da6107be565b3480156103a0575f5ffd5b506103b46103af36600461210a565b6107cd565b60405190151581526020016101e7565b3480156103cf575f5ffd5b506103396103de366004612132565b61081f565b3480156103ee575f5ffd5b5061020f6103fd366004612149565b6108d5565b610339610978565b348015610415575f5ffd5b5060095461020f565b348015610429575f5ffd5b506103396104383660046121b3565b610a83565b348015610448575f5ffd5b50610339610a92565b34801561045c575f5ffd5b5061020f61046b3660046121f2565b610bca565b34801561047b575f5ffd5b5061020f61048a366004612149565b610c26565b34801561049a575f5ffd5b5061020f6104a936600461227b565b610cab565b3480156104b9575f5ffd5b506103396104c8366004611e9a565b610d4a565b6060600480546104dc906122b5565b80601f0160208091040260200160405190810160405280929190818152602001828054610508906122b5565b80156105535780601f1061052a57610100808354040283529160200191610553565b820191905f5260205f20905b81548152906001019060200180831161053657829003601f168201915b5050505050905090565b5f6105a733866105a28787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610d8792505050565b610d94565b95945050505050565b5f6105bb88336107cd565b883390916105f457604051631ae7729b60e11b81526001600160a01b039283166004820152911660248201526044015b60405180910390fd5b5050610641888861063a8989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610d8792505050565b8686610e14565b905061064d8133610e6b565b50979650505050505050565b6060600680546104dc906122b5565b5f6106738433610e7d565b843390916106a65760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b50506106b53386868686610e14565b90506106c18133610e6b565b50949350505050565b5f6106d58233610e7d565b823390916107085760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b5050610715338484610d94565b90505b92915050565b610726610e88565b61072f5f610eb5565b565b61073b8382610f1e565b5f83815260026020526040902054838161076b57604051630ab5f57d60e01b81526004016105eb91815260200190565b5060405167ffffffffffffffff8416815281907f83bbbc07896439e5d950a6cead04cbc676180af7a61cecf43f5296475057f5719060200160405180910390a25050505f90815260026020526040812055565b6060600580546104dc906122b5565b5f816001600160a01b0316836001600160a01b031614806107155750506001600160a01b039182165f90815260016020908152604080832093909416825291909152205465ffffffffffff1642111590565b6108298133610e7d565b801561083a575061083a8130610e7d565b8133909161086d5760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b50506040805160018082528183019092525f916020808301908036833701905050905081815f815181106108a3576108a36122ed565b60209081029190910101525f6108c082631c9e789960e21b610f85565b5f908152600260205260409020929092555050565b5f6108e08433610e7d565b843390916109135760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b505061091f86336107cd565b8633909161095357604051631ae7729b60e11b81526001600160a01b039283166004820152911660248201526044016105eb565b50506109628686868686610e14565b905061096e8133610e6b565b5095945050505050565b5f34116109d35760405162461bcd60e51b815260206004820152602360248201527f436f6e666964656e7469616c574554483a2043616e6e6f74207772617020302060448201526208aa8960eb1b60648201526084016105eb565b5f6109dd34610f91565b335f908152600860205260409020549091506109f99082610fa7565b335f90815260086020526040902055600954610a159082610fa7565b600955335f90815260086020526040902054610a3090610fd5565b50335f81815260086020526040902054610a4991610fe4565b50610a55600954610fd5565b5060405133907f9cb777e5cc5a3050cb652a50361cf4e165e4706a58b64a46634d986cd91d4de1905f90a250565b610a8e338383610fef565b5050565b610a9a610e88565b4780610af45760405162461bcd60e51b8152602060048201526024808201527f436f6e666964656e7469616c574554483a204e6f2045544820746f20776974686044820152636472617760e01b60648201526084016105eb565b5f610b076007546001600160a01b031690565b6001600160a01b0316826040515f6040518083038185875af1925050503d805f8114610b4e576040519150601f19603f3d011682016040523d82523d5f602084013e610b53565b606091505b5050905080610a8e5760405162461bcd60e51b815260206004820152602d60248201527f436f6e666964656e7469616c574554483a20456d657267656e6379207769746860448201527f64726177616c206661696c65640000000000000000000000000000000000000060648201526084016105eb565b5f610c0f338861063a8989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610d8792505050565b9050610c1b8133610e6b565b509695505050505050565b5f610c3186336107cd565b86339091610c6557604051631ae7729b60e11b81526001600160a01b039283166004820152911660248201526044016105eb565b505061096286866105a28787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610d8792505050565b5f610cb68233610e7d565b82339091610ce95760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b5050610cf584336107cd565b84339091610d2957604051631ae7729b60e11b81526001600160a01b039283166004820152911660248201526044016105eb565b5050610d36848484610d94565b9050610d428133610e6b565b509392505050565b610d52610e88565b6001600160a01b038116610d7b57604051631e4fbdf760e01b81525f60048201526024016105eb565b610d8481610eb5565b50565b5f61071583836005611066565b5f806001600160a01b038516610dc957604051631a9bbf8b60e11b81526001600160a01b0390911660048201526024016105eb565b505f6001600160a01b038416610dfe57604051636e41946d60e11b81526001600160a01b0390911660048201526024016105eb565b50610e0a848484611173565b90505b9392505050565b5f5f610e21878787610d94565b90505f610e323389898589896112d3565b90505f610e52888a610e4d85610e475f610f91565b886113d7565b611173565b9050610e5e83826113e3565b9998505050505050505050565b5f610e768383611411565b5090919050565b5f6107158383611485565b6007546001600160a01b0316331461072f5760405163118cdaa760e01b81523360048201526024016105eb565b600780546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b5f610f2883611511565b90505f610f3582846115e2565b905080610f555760405163cf6c44e960e01b815260040160405180910390fd5b60405184907f1af0453083661051f6e56e5c070792320652e612154bf9af8637bb1e7655b99d905f90a250505050565b5f61071583835f6116ea565b5f6107188267ffffffffffffffff166005611823565b5f82610fb957610fb65f610f91565b92505b81610fca57610fc75f610f91565b91505b61071583835f6118c5565b5f610fe0823061198b565b5090565b5f610e76838361198b565b6001600160a01b038381165f81815260016020908152604080832094871680845294825291829020805465ffffffffffff191665ffffffffffff871690811790915591519182527f921a218a75d18e8ec5704851e6b234a85725b21a2521ce889622c35dedc1fa12910160405180910390a3505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6015460405163196d0b9b60e01b81525f915f5160206125515f395f51905f52916001600160a01b039091169063196d0b9b906110cc908890339089908990600401612335565b6020604051808303815f875af11580156110e8573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061110c919061236b565b8154604051630f8e573b60e21b8152600481018390523360248201529193506001600160a01b031690633e395cec906044015f604051808303815f87803b158015611155575f5ffd5b505af1158015611167573d5f5f3e3d5ffd5b50505050509392505050565b5f80806001600160a01b0386166111a957611190600954856119d1565b909250905061119e81610fd5565b50600981905561122d565b6001600160a01b0386165f9081526008602052604090205486816111ec57604051636b8830d760e11b81526001600160a01b0390911660048201526024016105eb565b506111f78186611a1b565b909350915061120582610fd5565b506112108288610fe4565b50506001600160a01b0386165f9081526008602052604090208190555b611240828561123b5f610f91565b6113d7565b92506001600160a01b0385166112725761125c600954846113e3565b905061126781610fd5565b5060098190556112ca565b6001600160a01b0385165f9081526008602052604090205461129481856119d1565b90935091506112a282610fd5565b506112ad8287610fe4565b50506001600160a01b0385165f9081526008602052604090208190555b50509392505050565b5f6001600160a01b0385163b156113c0576040516346083bfd60e01b81526001600160a01b038616906346083bfd90611318908a908a90899089908990600401612382565b6020604051808303815f875af1925050508015611352575060408051601f3d908101601f1916820190925261134f9181019061236b565b60015b6113b9573d80801561137f576040519150601f19603f3d011682016040523d82523d5f602084013e611384565b606091505b5080515f036113b157604051636e41946d60e11b81526001600160a01b03871660048201526024016105eb565b805181602001fd5b90506113cd565b6113ca6001611a46565b90505b9695505050505050565b5f610e0a848484611a61565b5f826113f5576113f25f610f91565b92505b81611406576114035f610f91565b91505b61071583835f611aee565b5f5160206125515f395f51905f528054604051630f8e573b60e21b8152600481018590526001600160a01b03848116602483015290911690633e395cec906044015b5f604051808303815f87803b15801561146a575f5ffd5b505af115801561147c573d5f5f3e3d5ffd5b50505050505050565b5f805f5160206125515f395f51905f5280546040516382027b6d60e01b8152600481018790526001600160a01b0386811660248301529293509116906382027b6d90604401602060405180830381865afa1580156114e5573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061150991906123d7565b949350505050565b5f8181527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0260205260408120546060917f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d009190036115825760405163d66ca67560e01b815260040160405180910390fd5b5f838152600282016020908152604091829020805483518184028101840190945280845290918301828280156115d557602002820191905f5260205f20905b8154815260200190600101908083116115c1575b5050505050915050919050565b5f6024816115ef85611b78565b90505f8167ffffffffffffffff81111561160b5761160b611f74565b6040519080825280601f01601f191660200182016040528015611635576020820181803683370190505b509050818360208301377fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60254604051632c027b1360e21b81525f5160206125515f395f51905f52916001600160a01b03169063b009ec4c9061169f908a9086908b90600401612430565b6020604051808303815f875af11580156116bb573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116df91906123d7565b979650505050505050565b7f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d01545f5160206125515f395f51905f528054604051637d6e912360e11b81527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0092916001600160a01b03169063fadd22469061176a9089906004016124ba565b5f604051808303815f87803b158015611781575f5ffd5b505af1158015611793573d5f5f3e3d5ffd5b50508354604051633263b83b60e01b81526001600160a01b039091169250633263b83b915086906117cc9087908b908b906004016124cc565b5f604051808303818588803b1580156117e3575f5ffd5b505af11580156117f5573d5f5f3e3d5ffd5b50505050506118048387611c25565b600182018054905f61181583612511565b919050555050509392505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60154604051639cd07acb60e01b81525f915f5160206125515f395f51905f52916001600160a01b0390911690639cd07acb906118859087908790600401612529565b6020604051808303815f875af11580156118a1573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611509919061236b565b5f5f82156118d85750600160f81b6118db565b505f5b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6015460405163022f65e760e31b815260048101879052602481018690526001600160f81b0319831660448201525f5160206125515f395f51905f52916001600160a01b03169063117b2f38906064015b6020604051808303815f875af1158015611967573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113cd919061236b565b5f5160206125515f395f51905f528054604051635ca4b5b160e11b8152600481018590526001600160a01b0384811660248301529091169063b9496b6290604401611453565b5f80836119ec576119e26001611a46565b9150829050611a14565b5f6119f78585610fa7565b9050611a038186611cb8565b9250611a108382876113d7565b9150505b9250929050565b5f5f611a278484611cb8565b9150611a3d82611a3786866113e3565b866113d7565b90509250929050565b5f61071882611a55575f611a58565b60015b60ff165f611823565b5f805f5160206125515f395f51905f526001810154604051637702dcff60e01b81526004810188905260248101879052604481018690529192506001600160a01b031690637702dcff906064016020604051808303815f875af1158015611aca573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105a7919061236b565b5f5f8215611b015750600160f81b611b04565b505f5b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601546040516303056db360e31b815260048101879052602481018690526001600160f81b0319831660448201525f5160206125515f395f51905f52916001600160a01b03169063182b6d989060640161194b565b80515f9081805b82811015611c19575f858281518110611b9a57611b9a6122ed565b6020026020010151601e60208110611bb457611bb46122ed565b1a6053811115611bc657611bc6612301565b90506009816053811115611bdc57611bdc612301565b60ff161015611bf757611bf060208461253d565b9250611c10565b60405163ce54a8d160e01b815260040160405180910390fd5b50600101611b7f565b5061150960208261253d565b5f8281527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0260205260409020547f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d009015611c9257604051633f06d22b60e01b815260040160405180910390fd5b5f83815260028201602090815260409091208351611cb292850190611d57565b50505050565b5f82611cca57611cc75f610f91565b92505b81611cdb57611cd85f610f91565b91505b61071583835f805f7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60154604051631391547f60e01b815260048101879052602481018690526001600160f81b0319831660448201525f5160206125515f395f51905f52916001600160a01b031690631391547f9060640161194b565b828054828255905f5260205f20908101928215611d90579160200282015b82811115611d90578251825591602001919060010190611d75565b50610fe09291505b80821115610fe0575f8155600101611d98565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6107156020830184611dab565b80356001600160a01b0381168114611e01575f5ffd5b919050565b5f5f83601f840112611e16575f5ffd5b50813567ffffffffffffffff811115611e2d575f5ffd5b602083019150836020828501011115611a14575f5ffd5b5f5f5f5f60608587031215611e57575f5ffd5b611e6085611deb565b935060208501359250604085013567ffffffffffffffff811115611e82575f5ffd5b611e8e87828801611e06565b95989497509550505050565b5f60208284031215611eaa575f5ffd5b61071582611deb565b5f5f5f5f5f5f5f60a0888a031215611ec9575f5ffd5b611ed288611deb565b9650611ee060208901611deb565b955060408801359450606088013567ffffffffffffffff811115611f02575f5ffd5b611f0e8a828b01611e06565b909550935050608088013567ffffffffffffffff811115611f2d575f5ffd5b611f398a828b01611e06565b989b979a50959850939692959293505050565b5f5f60408385031215611f5d575f5ffd5b611f6683611deb565b946020939093013593505050565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611fb157611fb1611f74565b604052919050565b5f5f5f60608486031215611fcb575f5ffd5b83359250602084013567ffffffffffffffff81168114611fe9575f5ffd5b9150604084013567ffffffffffffffff811115612004575f5ffd5b8401601f81018613612014575f5ffd5b803567ffffffffffffffff81111561202e5761202e611f74565b8060051b61203e60208201611f88565b91825260208184018101929081019089841115612059575f5ffd5b6020850192505b838310156120fb57823567ffffffffffffffff81111561207e575f5ffd5b8501603f81018b1361208e575f5ffd5b602081013567ffffffffffffffff8111156120ab576120ab611f74565b6120be601f8201601f1916602001611f88565b8181526040838301018d10156120d2575f5ffd5b816040840160208301375f60208383010152808552505050602082019150602083019250612060565b80955050505050509250925092565b5f5f6040838503121561211b575f5ffd5b61212483611deb565b9150611a3d60208401611deb565b5f60208284031215612142575f5ffd5b5035919050565b5f5f5f5f5f6080868803121561215d575f5ffd5b61216686611deb565b945061217460208701611deb565b935060408601359250606086013567ffffffffffffffff811115612196575f5ffd5b6121a288828901611e06565b969995985093965092949392505050565b5f5f604083850312156121c4575f5ffd5b6121cd83611deb565b9150602083013565ffffffffffff811681146121e7575f5ffd5b809150509250929050565b5f5f5f5f5f5f60808789031215612207575f5ffd5b61221087611deb565b955060208701359450604087013567ffffffffffffffff811115612232575f5ffd5b61223e89828a01611e06565b909550935050606087013567ffffffffffffffff81111561225d575f5ffd5b61226989828a01611e06565b979a9699509497509295939492505050565b5f5f5f6060848603121561228d575f5ffd5b61229684611deb565b92506122a460208501611deb565b929592945050506040919091013590565b600181811c908216806122c957607f821691505b6020821081036122e757634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52602160045260245ffd5b6054811061233157634e487b7160e01b5f52602160045260245ffd5b9052565b8481526001600160a01b0384166020820152608060408201525f61235c6080830185611dab565b90506105a76060830184612315565b5f6020828403121561237b575f5ffd5b5051919050565b6001600160a01b03861681526001600160a01b038516602082015283604082015260806060820152816080820152818360a08301375f81830160a090810191909152601f909201601f19160101949350505050565b5f602082840312156123e7575f5ffd5b81518015158114610e0d575f5ffd5b5f8151808452602084019350602083015f5b82811015612426578151865260209586019590910190600101612408565b5093949350505050565b606081525f61244260608301866123f6565b82810360208401526124548186611dab565b9050828103604084015280845180835260208301915060208160051b840101602087015f5b838110156124ab57601f19868403018552612495838351611dab565b6020958601959093509190910190600101612479565b50909998505050505050505050565b602081525f61071560208301846123f6565b838152606060208201525f6124e460608301856123f6565b905063ffffffff60e01b83166040830152949350505050565b634e487b7160e01b5f52601160045260245ffd5b5f60018201612522576125226124fd565b5060010190565b82815260408101610e0d6020830184612315565b80820180821115610718576107186124fd56feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600a164736f6c634300081b000a68747470733a2f2f6170692e6578616d706c652e636f6d2f6d657461646174612f",
  "deployedBytecode": "0x608060405260043610610191575f3560e01c80638da5cb5b116100dc578063d4ea066411610087578063de64211911610062578063de64211914610451578063e064b9bb14610470578063eb3155b51461048f578063f2fde38b146104ae575f5ffd5b8063d4ea06641461040a578063d4febb961461041e578063db2e21bc1461043d575f5ffd5b8063c535803c116100b7578063c535803c146103c4578063c7b8a75e146103e3578063d46eb11914610402575f5ffd5b80638da5cb5b1461035a57806395d89b4114610381578063b6363cf214610395575f5ffd5b8063402dc4e41161013c5780635bebed7e116101175780635bebed7e14610306578063715018a6146103255780637279e2641461033b575f5ffd5b8063402dc4e41461029f578063537d3c50146102d357806354095227146102f2575f5ffd5b8063344ff1011161016c578063344ff1011461023857806334c457431461026c5780633c130d901461028b575f5ffd5b806306fdde03146101c65780632fb74e62146101f0578063313ce5671461021d575f5ffd5b366101c25760405133907fa5e14a44e1a528a28e895b7dc9df2e48d8717f0515104e15fefc03ad7401f561905f90a2005b5f5ffd5b3480156101d1575f5ffd5b506101da6104cd565b6040516101e79190611dd9565b60405180910390f35b3480156101fb575f5ffd5b5061020f61020a366004611e44565b61055d565b6040519081526020016101e7565b348015610228575f5ffd5b50604051600681526020016101e7565b348015610243575f5ffd5b5061020f610252366004611e9a565b6001600160a01b03165f9081526020819052604090205490565b348015610277575f5ffd5b5061020f610286366004611eb3565b6105b0565b348015610296575f5ffd5b506101da610659565b3480156102aa575f5ffd5b5061020f6102b9366004611e9a565b6001600160a01b03165f9081526008602052604090205490565b3480156102de575f5ffd5b5061020f6102ed366004611e44565b610668565b3480156102fd575f5ffd5b5060035461020f565b348015610311575f5ffd5b5061020f610320366004611f4c565b6106ca565b348015610330575f5ffd5b5061033961071e565b005b348015610346575f5ffd5b50610339610355366004611fb9565b610731565b348015610365575f5ffd5b506007546040516001600160a01b0390911681526020016101e7565b34801561038c575f5ffd5b506101da6107be565b3480156103a0575f5ffd5b506103b46103af36600461210a565b6107cd565b60405190151581526020016101e7565b3480156103cf575f5ffd5b506103396103de366004612132565b61081f565b3480156103ee575f5ffd5b5061020f6103fd366004612149565b6108d5565b610339610978565b348015610415575f5ffd5b5060095461020f565b348015610429575f5ffd5b506103396104383660046121b3565b610a83565b348015610448575f5ffd5b50610339610a92565b34801561045c575f5ffd5b5061020f61046b3660046121f2565b610bca565b34801561047b575f5ffd5b5061020f61048a366004612149565b610c26565b34801561049a575f5ffd5b5061020f6104a936600461227b565b610cab565b3480156104b9575f5ffd5b506103396104c8366004611e9a565b610d4a565b6060600480546104dc906122b5565b80601f0160208091040260200160405190810160405280929190818152602001828054610508906122b5565b80156105535780601f1061052a57610100808354040283529160200191610553565b820191905f5260205f20905b81548152906001019060200180831161053657829003601f168201915b5050505050905090565b5f6105a733866105a28787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610d8792505050565b610d94565b95945050505050565b5f6105bb88336107cd565b883390916105f457604051631ae7729b60e11b81526001600160a01b039283166004820152911660248201526044015b60405180910390fd5b5050610641888861063a8989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610d8792505050565b8686610e14565b905061064d8133610e6b565b50979650505050505050565b6060600680546104dc906122b5565b5f6106738433610e7d565b843390916106a65760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b50506106b53386868686610e14565b90506106c18133610e6b565b50949350505050565b5f6106d58233610e7d565b823390916107085760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b5050610715338484610d94565b90505b92915050565b610726610e88565b61072f5f610eb5565b565b61073b8382610f1e565b5f83815260026020526040902054838161076b57604051630ab5f57d60e01b81526004016105eb91815260200190565b5060405167ffffffffffffffff8416815281907f83bbbc07896439e5d950a6cead04cbc676180af7a61cecf43f5296475057f5719060200160405180910390a25050505f90815260026020526040812055565b6060600580546104dc906122b5565b5f816001600160a01b0316836001600160a01b031614806107155750506001600160a01b039182165f90815260016020908152604080832093909416825291909152205465ffffffffffff1642111590565b6108298133610e7d565b801561083a575061083a8130610e7d565b8133909161086d5760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b50506040805160018082528183019092525f916020808301908036833701905050905081815f815181106108a3576108a36122ed565b60209081029190910101525f6108c082631c9e789960e21b610f85565b5f908152600260205260409020929092555050565b5f6108e08433610e7d565b843390916109135760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b505061091f86336107cd565b8633909161095357604051631ae7729b60e11b81526001600160a01b039283166004820152911660248201526044016105eb565b50506109628686868686610e14565b905061096e8133610e6b565b5095945050505050565b5f34116109d35760405162461bcd60e51b815260206004820152602360248201527f436f6e666964656e7469616c574554483a2043616e6e6f74207772617020302060448201526208aa8960eb1b60648201526084016105eb565b5f6109dd34610f91565b335f908152600860205260409020549091506109f99082610fa7565b335f90815260086020526040902055600954610a159082610fa7565b600955335f90815260086020526040902054610a3090610fd5565b50335f81815260086020526040902054610a4991610fe4565b50610a55600954610fd5565b5060405133907f9cb777e5cc5a3050cb652a50361cf4e165e4706a58b64a46634d986cd91d4de1905f90a250565b610a8e338383610fef565b5050565b610a9a610e88565b4780610af45760405162461bcd60e51b8152602060048201526024808201527f436f6e666964656e7469616c574554483a204e6f2045544820746f20776974686044820152636472617760e01b60648201526084016105eb565b5f610b076007546001600160a01b031690565b6001600160a01b0316826040515f6040518083038185875af1925050503d805f8114610b4e576040519150601f19603f3d011682016040523d82523d5f602084013e610b53565b606091505b5050905080610a8e5760405162461bcd60e51b815260206004820152602d60248201527f436f6e666964656e7469616c574554483a20456d657267656e6379207769746860448201527f64726177616c206661696c65640000000000000000000000000000000000000060648201526084016105eb565b5f610c0f338861063a8989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610d8792505050565b9050610c1b8133610e6b565b509695505050505050565b5f610c3186336107cd565b86339091610c6557604051631ae7729b60e11b81526001600160a01b039283166004820152911660248201526044016105eb565b505061096286866105a28787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610d8792505050565b5f610cb68233610e7d565b82339091610ce95760405163118f6e5360e31b815260048101929092526001600160a01b031660248201526044016105eb565b5050610cf584336107cd565b84339091610d2957604051631ae7729b60e11b81526001600160a01b039283166004820152911660248201526044016105eb565b5050610d36848484610d94565b9050610d428133610e6b565b509392505050565b610d52610e88565b6001600160a01b038116610d7b57604051631e4fbdf760e01b81525f60048201526024016105eb565b610d8481610eb5565b50565b5f61071583836005611066565b5f806001600160a01b038516610dc957604051631a9bbf8b60e11b81526001600160a01b0390911660048201526024016105eb565b505f6001600160a01b038416610dfe57604051636e41946d60e11b81526001600160a01b0390911660048201526024016105eb565b50610e0a848484611173565b90505b9392505050565b5f5f610e21878787610d94565b90505f610e323389898589896112d3565b90505f610e52888a610e4d85610e475f610f91565b886113d7565b611173565b9050610e5e83826113e3565b9998505050505050505050565b5f610e768383611411565b5090919050565b5f6107158383611485565b6007546001600160a01b0316331461072f5760405163118cdaa760e01b81523360048201526024016105eb565b600780546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b5f610f2883611511565b90505f610f3582846115e2565b905080610f555760405163cf6c44e960e01b815260040160405180910390fd5b60405184907f1af0453083661051f6e56e5c070792320652e612154bf9af8637bb1e7655b99d905f90a250505050565b5f61071583835f6116ea565b5f6107188267ffffffffffffffff166005611823565b5f82610fb957610fb65f610f91565b92505b81610fca57610fc75f610f91565b91505b61071583835f6118c5565b5f610fe0823061198b565b5090565b5f610e76838361198b565b6001600160a01b038381165f81815260016020908152604080832094871680845294825291829020805465ffffffffffff191665ffffffffffff871690811790915591519182527f921a218a75d18e8ec5704851e6b234a85725b21a2521ce889622c35dedc1fa12910160405180910390a3505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6015460405163196d0b9b60e01b81525f915f5160206125515f395f51905f52916001600160a01b039091169063196d0b9b906110cc908890339089908990600401612335565b6020604051808303815f875af11580156110e8573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061110c919061236b565b8154604051630f8e573b60e21b8152600481018390523360248201529193506001600160a01b031690633e395cec906044015f604051808303815f87803b158015611155575f5ffd5b505af1158015611167573d5f5f3e3d5ffd5b50505050509392505050565b5f80806001600160a01b0386166111a957611190600954856119d1565b909250905061119e81610fd5565b50600981905561122d565b6001600160a01b0386165f9081526008602052604090205486816111ec57604051636b8830d760e11b81526001600160a01b0390911660048201526024016105eb565b506111f78186611a1b565b909350915061120582610fd5565b506112108288610fe4565b50506001600160a01b0386165f9081526008602052604090208190555b611240828561123b5f610f91565b6113d7565b92506001600160a01b0385166112725761125c600954846113e3565b905061126781610fd5565b5060098190556112ca565b6001600160a01b0385165f9081526008602052604090205461129481856119d1565b90935091506112a282610fd5565b506112ad8287610fe4565b50506001600160a01b0385165f9081526008602052604090208190555b50509392505050565b5f6001600160a01b0385163b156113c0576040516346083bfd60e01b81526001600160a01b038616906346083bfd90611318908a908a90899089908990600401612382565b6020604051808303815f875af1925050508015611352575060408051601f3d908101601f1916820190925261134f9181019061236b565b60015b6113b9573d80801561137f576040519150601f19603f3d011682016040523d82523d5f602084013e611384565b606091505b5080515f036113b157604051636e41946d60e11b81526001600160a01b03871660048201526024016105eb565b805181602001fd5b90506113cd565b6113ca6001611a46565b90505b9695505050505050565b5f610e0a848484611a61565b5f826113f5576113f25f610f91565b92505b81611406576114035f610f91565b91505b61071583835f611aee565b5f5160206125515f395f51905f528054604051630f8e573b60e21b8152600481018590526001600160a01b03848116602483015290911690633e395cec906044015b5f604051808303815f87803b15801561146a575f5ffd5b505af115801561147c573d5f5f3e3d5ffd5b50505050505050565b5f805f5160206125515f395f51905f5280546040516382027b6d60e01b8152600481018790526001600160a01b0386811660248301529293509116906382027b6d90604401602060405180830381865afa1580156114e5573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061150991906123d7565b949350505050565b5f8181527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0260205260408120546060917f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d009190036115825760405163d66ca67560e01b815260040160405180910390fd5b5f838152600282016020908152604091829020805483518184028101840190945280845290918301828280156115d557602002820191905f5260205f20905b8154815260200190600101908083116115c1575b5050505050915050919050565b5f6024816115ef85611b78565b90505f8167ffffffffffffffff81111561160b5761160b611f74565b6040519080825280601f01601f191660200182016040528015611635576020820181803683370190505b509050818360208301377fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60254604051632c027b1360e21b81525f5160206125515f395f51905f52916001600160a01b03169063b009ec4c9061169f908a9086908b90600401612430565b6020604051808303815f875af11580156116bb573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116df91906123d7565b979650505050505050565b7f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d01545f5160206125515f395f51905f528054604051637d6e912360e11b81527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0092916001600160a01b03169063fadd22469061176a9089906004016124ba565b5f604051808303815f87803b158015611781575f5ffd5b505af1158015611793573d5f5f3e3d5ffd5b50508354604051633263b83b60e01b81526001600160a01b039091169250633263b83b915086906117cc9087908b908b906004016124cc565b5f604051808303818588803b1580156117e3575f5ffd5b505af11580156117f5573d5f5f3e3d5ffd5b50505050506118048387611c25565b600182018054905f61181583612511565b919050555050509392505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60154604051639cd07acb60e01b81525f915f5160206125515f395f51905f52916001600160a01b0390911690639cd07acb906118859087908790600401612529565b6020604051808303815f875af11580156118a1573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611509919061236b565b5f5f82156118d85750600160f81b6118db565b505f5b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6015460405163022f65e760e31b815260048101879052602481018690526001600160f81b0319831660448201525f5160206125515f395f51905f52916001600160a01b03169063117b2f38906064015b6020604051808303815f875af1158015611967573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113cd919061236b565b5f5160206125515f395f51905f528054604051635ca4b5b160e11b8152600481018590526001600160a01b0384811660248301529091169063b9496b6290604401611453565b5f80836119ec576119e26001611a46565b9150829050611a14565b5f6119f78585610fa7565b9050611a038186611cb8565b9250611a108382876113d7565b9150505b9250929050565b5f5f611a278484611cb8565b9150611a3d82611a3786866113e3565b866113d7565b90509250929050565b5f61071882611a55575f611a58565b60015b60ff165f611823565b5f805f5160206125515f395f51905f526001810154604051637702dcff60e01b81526004810188905260248101879052604481018690529192506001600160a01b031690637702dcff906064016020604051808303815f875af1158015611aca573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105a7919061236b565b5f5f8215611b015750600160f81b611b04565b505f5b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601546040516303056db360e31b815260048101879052602481018690526001600160f81b0319831660448201525f5160206125515f395f51905f52916001600160a01b03169063182b6d989060640161194b565b80515f9081805b82811015611c19575f858281518110611b9a57611b9a6122ed565b6020026020010151601e60208110611bb457611bb46122ed565b1a6053811115611bc657611bc6612301565b90506009816053811115611bdc57611bdc612301565b60ff161015611bf757611bf060208461253d565b9250611c10565b60405163ce54a8d160e01b815260040160405180910390fd5b50600101611b7f565b5061150960208261253d565b5f8281527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0260205260409020547f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d009015611c9257604051633f06d22b60e01b815260040160405180910390fd5b5f83815260028201602090815260409091208351611cb292850190611d57565b50505050565b5f82611cca57611cc75f610f91565b92505b81611cdb57611cd85f610f91565b91505b61071583835f805f7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60154604051631391547f60e01b815260048101879052602481018690526001600160f81b0319831660448201525f5160206125515f395f51905f52916001600160a01b031690631391547f9060640161194b565b828054828255905f5260205f20908101928215611d90579160200282015b82811115611d90578251825591602001919060010190611d75565b50610fe09291505b80821115610fe0575f8155600101611d98565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6107156020830184611dab565b80356001600160a01b0381168114611e01575f5ffd5b919050565b5f5f83601f840112611e16575f5ffd5b50813567ffffffffffffffff811115611e2d575f5ffd5b602083019150836020828501011115611a14575f5ffd5b5f5f5f5f60608587031215611e57575f5ffd5b611e6085611deb565b935060208501359250604085013567ffffffffffffffff811115611e82575f5ffd5b611e8e87828801611e06565b95989497509550505050565b5f60208284031215611eaa575f5ffd5b61071582611deb565b5f5f5f5f5f5f5f60a0888a031215611ec9575f5ffd5b611ed288611deb565b9650611ee060208901611deb565b955060408801359450606088013567ffffffffffffffff811115611f02575f5ffd5b611f0e8a828b01611e06565b909550935050608088013567ffffffffffffffff811115611f2d575f5ffd5b611f398a828b01611e06565b989b979a50959850939692959293505050565b5f5f60408385031215611f5d575f5ffd5b611f6683611deb565b946020939093013593505050565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611fb157611fb1611f74565b604052919050565b5f5f5f60608486031215611fcb575f5ffd5b83359250602084013567ffffffffffffffff81168114611fe9575f5ffd5b9150604084013567ffffffffffffffff811115612004575f5ffd5b8401601f81018613612014575f5ffd5b803567ffffffffffffffff81111561202e5761202e611f74565b8060051b61203e60208201611f88565b91825260208184018101929081019089841115612059575f5ffd5b6020850192505b838310156120fb57823567ffffffffffffffff81111561207e575f5ffd5b8501603f81018b1361208e575f5ffd5b602081013567ffffffffffffffff8111156120ab576120ab611f74565b6120be601f8201601f1916602001611f88565b8181526040838301018d10156120d2575f5ffd5b816040840160208301375f60208383010152808552505050602082019150602083019250612060565b80955050505050509250925092565b5f5f6040838503121561211b575f5ffd5b61212483611deb565b9150611a3d60208401611deb565b5f60208284031215612142575f5ffd5b5035919050565b5f5f5f5f5f6080868803121561215d575f5ffd5b61216686611deb565b945061217460208701611deb565b935060408601359250606086013567ffffffffffffffff811115612196575f5ffd5b6121a288828901611e06565b969995985093965092949392505050565b5f5f604083850312156121c4575f5ffd5b6121cd83611deb565b9150602083013565ffffffffffff811681146121e7575f5ffd5b809150509250929050565b5f5f5f5f5f5f60808789031215612207575f5ffd5b61221087611deb565b955060208701359450604087013567ffffffffffffffff811115612232575f5ffd5b61223e89828a01611e06565b909550935050606087013567ffffffffffffffff81111561225d575f5ffd5b61226989828a01611e06565b979a9699509497509295939492505050565b5f5f5f6060848603121561228d575f5ffd5b61229684611deb565b92506122a460208501611deb565b929592945050506040919091013590565b600181811c908216806122c957607f821691505b6020821081036122e757634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52602160045260245ffd5b6054811061233157634e487b7160e01b5f52602160045260245ffd5b9052565b8481526001600160a01b0384166020820152608060408201525f61235c6080830185611dab565b90506105a76060830184612315565b5f6020828403121561237b575f5ffd5b5051919050565b6001600160a01b03861681526001600160a01b038516602082015283604082015260806060820152816080820152818360a08301375f81830160a090810191909152601f909201601f19160101949350505050565b5f602082840312156123e7575f5ffd5b81518015158114610e0d575f5ffd5b5f8151808452602084019350602083015f5b82811015612426578151865260209586019590910190600101612408565b5093949350505050565b606081525f61244260608301866123f6565b82810360208401526124548186611dab565b9050828103604084015280845180835260208301915060208160051b840101602087015f5b838110156124ab57601f19868403018552612495838351611dab565b6020958601959093509190910190600101612479565b50909998505050505050505050565b602081525f61071560208301846123f6565b838152606060208201525f6124e460608301856123f6565b905063ffffffff60e01b83166040830152949350505050565b634e487b7160e01b5f52601160045260245ffd5b5f60018201612522576125226124fd565b5060010190565b82815260408101610e0d6020830184612315565b80820180821115610718576107186124fd56feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600a164736f6c634300081b000a",
  "devdoc": {
    "details": "This contract allows users to wrap ETH into confidential WETH tokens",
    "errors": {
      "ConfidentialFungibleTokenInvalidGatewayRequest(uint256)": [
        {
          "details": "The given gateway request ID `requestId` is invalid."
        }
      ],
      "ConfidentialFungibleTokenInvalidReceiver(address)": [
        {
          "details": "The given receiver `receiver` is invalid for transfers."
        }
      ],
      "ConfidentialFungibleTokenInvalidSender(address)": [
        {
          "details": "The given sender `sender` is invalid for transfers."
        }
      ],
      "ConfidentialFungibleTokenUnauthorizedCaller(address)": [
        {
          "details": "The given caller `caller` is not authorized for the current operation."
        }
      ],
      "ConfidentialFungibleTokenUnauthorizedSpender(address,address)": [
        {
          "details": "The given holder `holder` is not authorized to spend on behalf of `spender`."
        }
      ],
      "ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(bytes32,address)": [
        {
          "details": "The caller `user` does not have access to the encrypted amount `amount`. NOTE: Try using the equivalent transfer function with an input proof."
        }
      ],
      "ConfidentialFungibleTokenZeroBalance(address)": [
        {
          "details": "The holder `holder` is trying to send tokens but has a balance of 0."
        }
      ],
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ]
    },
    "events": {
      "AmountDisclosed(bytes32,uint64)": {
        "details": "Emitted when an encrypted amount is disclosed. Accounts with access to the encrypted amount `encryptedAmount` that is also accessible to this contract should be able to disclose the amount. This functionality is implementation specific."
      },
      "ConfidentialTransfer(address,address,bytes32)": {
        "details": "Emitted when a confidential transfer is made from `from` to `to` of encrypted amount `amount`."
      },
      "OperatorSet(address,address,uint48)": {
        "details": "Emitted when the expiration timestamp for an operator `operator` is updated for a given `holder`. The operator may move any amount of tokens on behalf of the holder until the timestamp `until`."
      }
    },
    "kind": "dev",
    "methods": {
      "confidentialBalanceOf(address)": {
        "details": "Returns the confidential balance of the account `account`."
      },
      "confidentialTotalSupply()": {
        "details": "Returns the confidential total supply of the token."
      },
      "confidentialTransfer(address,bytes32)": {
        "details": "Similar to {confidentialTransfer-address-externalEuint64-bytes} but without an input proof. The caller *must* already be allowed by ACL for the given `amount`."
      },
      "confidentialTransfer(address,bytes32,bytes)": {
        "details": "Transfers the encrypted amount `encryptedAmount` to `to` with the given input proof `inputProof`. Returns the encrypted amount that was actually transferred."
      },
      "confidentialTransferAndCall(address,bytes32,bytes)": {
        "details": "Similar to {confidentialTransfer-address-euint64} but with a callback to `to` after the transfer."
      },
      "confidentialTransferAndCall(address,bytes32,bytes,bytes)": {
        "details": "Similar to {confidentialTransfer-address-externalEuint64-bytes} but with a callback to `to` after the transfer. The callback is made to the {IConfidentialFungibleTokenReceiver-onConfidentialTransferReceived} function on the to address with the actual transferred amount (may differ from the given `encryptedAmount`) and the given data `data`."
      },
      "confidentialTransferFrom(address,address,bytes32)": {
        "details": "Similar to {confidentialTransferFrom-address-address-externalEuint64-bytes} but without an input proof. The caller *must* be already allowed by ACL for the given `amount`."
      },
      "confidentialTransferFrom(address,address,bytes32,bytes)": {
        "details": "Transfers the encrypted amount `encryptedAmount` from `from` to `to` with the given input proof `inputProof`. `msg.sender` must be either `from` or an operator for `from`. Returns the encrypted amount that was actually transferred."
      },
      "confidentialTransferFromAndCall(address,address,bytes32,bytes)": {
        "details": "Similar to {confidentialTransferFrom-address-address-euint64} but with a callback to `to` after the transfer."
      },
      "confidentialTransferFromAndCall(address,address,bytes32,bytes,bytes)": {
        "details": "Similar to {confidentialTransferFrom-address-address-externalEuint64-bytes} but with a callback to `to` after the transfer."
      },
      "decimals()": {
        "details": "Returns the number of decimals of the token. Recommended to be 6."
      },
      "discloseEncryptedAmount(bytes32)": {
        "details": "Discloses an encrypted amount `encryptedAmount` publicly via an {IConfidentialFungibleToken-AmountDisclosed} event. The caller and this contract must be authorized to use the encrypted amount on the ACL. NOTE: This is an asynchronous operation where the actual decryption happens off-chain and {finalizeDiscloseEncryptedAmount} is called with the result."
      },
      "emergencyWithdraw()": {
        "details": "This function should only be used in emergency situations"
      },
      "finalizeDiscloseEncryptedAmount(uint256,uint64,bytes[])": {
        "details": "Finalizes a disclose encrypted amount request."
      },
      "getEncryptedBalance(address)": {
        "params": {
          "user": "The user address"
        },
        "returns": {
          "_0": "The encrypted balance"
        }
      },
      "getEncryptedTotalSupply()": {
        "returns": {
          "_0": "The encrypted total supply"
        }
      },
      "isOperator(address,address)": {
        "details": "Returns true if `spender` is currently an operator for `holder`."
      },
      "name()": {
        "details": "Returns the name of the token."
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "setOperator(address,uint48)": {
        "details": "Sets `operator` as an operator for `holder` until the timestamp `until`. NOTE: An operator may transfer any amount of tokens on behalf of a holder while approved."
      },
      "symbol()": {
        "details": "Returns the symbol of the token."
      },
      "tokenURI()": {
        "details": "Returns the token URI."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "wrap()": {
        "details": "Users send ETH and receive encrypted cWETH tokensCONFIDENTIAL: No plaintext amounts are exposed"
      }
    },
    "title": "Confidential WETH (cWETH)",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "HandlesAlreadySavedForRequestID()": [
        {
          "notice": "Returned if some handles were already saved for corresponding ID."
        }
      ],
      "InvalidKMSSignatures()": [
        {
          "notice": "Returned if the returned KMS signatures are not valid."
        }
      ],
      "NoHandleFoundForRequestID()": [
        {
          "notice": "Returned if there was not handle found for the requested ID."
        }
      ],
      "UnsupportedHandleType()": [
        {
          "notice": "Returned if the requested handle to be decrypted is not of a supported type."
        }
      ]
    },
    "events": {
      "DecryptionFulfilled(uint256)": {
        "notice": "This event is emitted when requested decryption has been fulfilled."
      }
    },
    "kind": "user",
    "methods": {
      "emergencyWithdraw()": {
        "notice": "Emergency function to withdraw ETH (only owner)"
      },
      "getEncryptedBalance(address)": {
        "notice": "Get encrypted balance of a user"
      },
      "getEncryptedTotalSupply()": {
        "notice": "Get encrypted total supply"
      },
      "wrap()": {
        "notice": "Wrap ETH into confidential WETH"
      }
    },
    "notice": "ERC7984 implementation for confidential WETH with wrap/unwrap functionality",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 39252,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_balances",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_userDefinedValueType(euint64)42256)"
      },
      {
        "astId": 39258,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_operators",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint48))"
      },
      {
        "astId": 39263,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_requestHandles",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_userDefinedValueType(euint64)42256)"
      },
      {
        "astId": 39266,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_totalSupply",
        "offset": 0,
        "slot": "3",
        "type": "t_userDefinedValueType(euint64)42256"
      },
      {
        "astId": 39268,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_name",
        "offset": 0,
        "slot": "4",
        "type": "t_string_storage"
      },
      {
        "astId": 39270,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_symbol",
        "offset": 0,
        "slot": "5",
        "type": "t_string_storage"
      },
      {
        "astId": 39272,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_tokenURI",
        "offset": 0,
        "slot": "6",
        "type": "t_string_storage"
      },
      {
        "astId": 40532,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_owner",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      },
      {
        "astId": 41894,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_encryptedBalances",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_address,t_userDefinedValueType(euint64)42256)"
      },
      {
        "astId": 41897,
        "contract": "contracts/ConfidentialWETH.sol:ConfidentialWETH",
        "label": "_totalSupply",
        "offset": 0,
        "slot": "9",
        "type": "t_userDefinedValueType(euint64)42256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint48))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint48))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint48)"
      },
      "t_mapping(t_address,t_uint48)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint48)",
        "numberOfBytes": "32",
        "value": "t_uint48"
      },
      "t_mapping(t_address,t_userDefinedValueType(euint64)42256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => euint64)",
        "numberOfBytes": "32",
        "value": "t_userDefinedValueType(euint64)42256"
      },
      "t_mapping(t_uint256,t_userDefinedValueType(euint64)42256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => euint64)",
        "numberOfBytes": "32",
        "value": "t_userDefinedValueType(euint64)42256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint48": {
        "encoding": "inplace",
        "label": "uint48",
        "numberOfBytes": "6"
      },
      "t_userDefinedValueType(euint64)42256": {
        "encoding": "inplace",
        "label": "euint64",
        "numberOfBytes": "32"
      }
    }
  }
}